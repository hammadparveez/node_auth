'use strict';
const MAX_SPAN_SIZE = 1024;
// const MAX_SPAN_DEPTH = 32;
// I am not sure how span depth would really work here
// TODO: later

const SEP = '$';
let Patch;
const getPatch = function () { // stupid loader race condition. TODO: optimize later

    if (Patch !== undefined) {
        return Patch;
    }
    Patch = require('../instrumentation/patch');
    return Patch;
};

/**
 * @param {string[]} fields
 */
const getKey = function (fields) {

    return fields.sort().join(SEP);
};

module.exports.Subscription = class {

    constructor(method, rule, noBudget) {

        this.method = method;
        this.rule = rule || {};
        this.noBudget = noBudget || false;
        this.method.noBudget = this.noBudget; // legacy interprop
    }
};

const SubscriptionGroup = module.exports.SubscriptionGroup = class {

    /**
     *
     * @param {string[]} fields
     * @return {SubscriptionGroup}
     */
    static getSubscriptionGroup(fields) {

        const hash = getKey(fields);
        return this.current.get(hash);
    }

    /**
     *
     * @param {string[]} fields
     * @return {SubscriptionGroup}
     */
    static getOrCreateSubscriptionGroup(fields) {

        const requiredFields = fields
            .filter((x) => x.optional !== true)
            .map((x) => {

                return typeof x === 'string' ? x : x.address;
            });
        const optionalFields = fields
            .filter((x) => x.optional === true)
            .map((x) =>  x.address);
        const hash = getKey(requiredFields);
        let group = this.current.get(hash);
        if (group === undefined) {
            group = new SubscriptionGroup(hash, requiredFields, optionalFields);
            this.current.set(hash, group);
        }
        else {
            // update optional fields
            optionalFields.forEach(group.optionalFields.add, group.optionalFields);
        }

        return group;
    }

    constructor(hash, fields, optionalFields) {

        this.hash = getKey(fields);
        this.subscriptions = [];
        this.fields = fields;
        this.optionalFields = new Set(optionalFields);
    }

    addSubscription(callback) {

        this.subscriptions.push(callback);
    }

    hasCallbacks() {

        return this.subscriptions.length !== 0;
    }

    removeSubscription(callback) {

        this.subscriptions = this.subscriptions.filter((cb) => cb !== callback);
        if (this.hasCallbacks() === false) {
            SubscriptionGroup.current.delete(this.hash); // remove self if there are no cbs anymore
        }
    }
};
SubscriptionGroup.current = new Map();

module.exports.SubscriptionManager = class {

    constructor() {

        /**
         * @type {Map<string, SubscriptionGroup[]>}
         */
        this.keyToSubscriptionGroups = new Map();
        this.allKeys = new Set();
        this.groupSet = new Set();
        this.hardNeededKeys = new Set();
    }

    addHardNeededKey(field) {

        this.allKeys.add(field);
        this.hardNeededKeys.add(field);
    }

    removeAllGroups() {

        this.keyToSubscriptionGroups = new Map();
        this.allKeys = new Set();
        this.groupSet = new Set();
        this.rebuildKeySet();
    }

    addGroup(group) {

        if (this.groupSet.has(group)) {
            return;
        }

        for (let i = 0; i < group.fields.length; ++i) {
            const key = group.fields[i];
            this.allKeys.add(key);
            let list = this.keyToSubscriptionGroups.get(key);
            if (list === undefined) {
                list = [];
                this.keyToSubscriptionGroups.set(key, list);
            }
            list.push(group);
        }
        this.groupSet.add(group);
    }

    /**
     * /!\ This method is very costly
     */
    rebuildKeySet() {

        const groupSet = new Set(Array.from(this.keyToSubscriptionGroups.values()).reduce((a, b) => a.concat(b), []));
        const res = this.allKeys = new Set();
        groupSet.forEach((group) => group.fields.forEach(res.add, res));
        this.hardNeededKeys.forEach((key) => {

            this.allKeys.add(key);
        });
    }

    /**
     * /!\ This method is very costly
     */
    removeGroupSet(groupSet) {

        groupSet.forEach((group) => {

            //$lab:coverage:off$
            if (!this.groupSet.has(group)) {
                return;
                //$lab:coverage:on$
            }
            this.groupSet.delete(group);

            for (let i = 0; i < group.fields.length; ++i) {
                const key = group.fields[i];
                const associatedGroups = this.keyToSubscriptionGroups.get(key);
                //$lab:coverage:off$
                if (associatedGroups === undefined) {
                    continue;
                    //$lab:coverage:on$
                }
                const newAssociatedGroups = associatedGroups.filter((x) => x !== group);
                this.keyToSubscriptionGroups.set(key, newAssociatedGroups);
            }
        });
        this.rebuildKeySet();
    }

    extractGroups(keyList, allKeys) {

        const subSet = new Set(); // set might be slower than array to iterate on. Might be a perf gain here
        const keySet = new Set();
        const knowGroups = new Set();
        for (let i = 0; i < keyList.length; ++i) {
            const groups = this.keyToSubscriptionGroups.get(keyList[i]);
            if (groups === undefined) {
                continue;
            }
            for (let j = 0; j < groups.length; ++j) {
                const group = groups[j];
                if (knowGroups.has(group) === true) {
                    continue; // we already have handled this ons
                }
                knowGroups.add(group);
                const isValid = group.fields.every((k) => allKeys.indexOf(k) > -1);
                if (isValid === true) {
                    group.fields.forEach(keySet.add, keySet);
                    group.optionalFields.forEach(keySet.add, keySet);
                    group.subscriptions.forEach(subSet.add, subSet);
                }
            }
        }
        return { keySet, subSet };
    }

    /**
     * @param {string[]} keyList
     * @param {Span} span
     */
    dispatch(keyList, span) {

        const result = this.extractGroups(span.keys, keyList);
        const subSet = result.subSet;
        const keySet = result.keySet;
        const params = {};
        keySet.forEach((key) => {

            params[key] = span.resolve(key);
        });
        return getPatch().runSubscriptionSet(subSet, params);
    }
};

const Span = module.exports.Span = class {

    static setManager(manager) {

        this.manager = manager;
    }

    createChild() {

        const parents = Array.from(this.parents);
        parents.push(this);
        return new Span(parents);
    }

    /**
     *
     * @param {Span[]} parents
     */
    constructor(parents) {

        /**
         * @type {Span[]}
         */
        this.parents = parents; // parent can be empty
        /**
         *
         * @type {Map<string, any>}
         */
        this.store = new Map();
        /**
         *
         * @type {string[]}
         */
        this.keys = [];
        this.initAllKeys();
    }

    initAllKeys() {

        const parentsLn = this.parents.length;
        this.allKeys = parentsLn > 0 ? Array.from(this.parents[parentsLn - 1].keys) : []; // Array.from is a faster solution it seems
    }

    cleanup() {

        this.initAllKeys();
        this.store = new Map();
        this.keys = [];
    }

    /**
     *
     * @param {string} key
     * @param {any} value
     * @return {Span}
     */
    setValue(key, value) {

        if (this.allKeys.length >= MAX_SPAN_SIZE) {
            return this;
        }

        this.store.set(key, value);
        if (this.keys.indexOf(key) > -1) {
            return this;
        }
        this.keys.push(key);
        this.allKeys.push(key);
        return this;
    }

    setMultipleValues(params) {

        const keyList = Object.keys(params);
        for (let i = 0; i < keyList.length; ++i) {
            const k = keyList[i];
            this.setValue(k, params[k]);
        }
        return this;
    }

    /**
     * @return {string[]}
     */
    getallKeys() {

        return this.allKeys;
    }

    dispatch() {

        return Span.manager.dispatch(this.getallKeys(), this);
    }

    resolve(key) {

        if (this.store.has(key) === true) {
            return this.store.get(key);
        }
        for (let i = this.parents.length - 1; i >= 0; --i) {
            const parent = this.parents[i]; // I don't want to use a reccursive loop here. I am not sure why
            if (parent.store.has(key) === true) {
                return parent.store.get(key);
            }
        }
        // Will be hit on optionals
        // Might be faster to have a pre-check based on allkeys in a set
        return null;
    }
};

