/**
 * Copyright (c) 2016 - 2021 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const VM = require('vm');

const UUID = require('uuid');

const Fuzzer = require('../../fuzzer');
const Logger = require('../../logger');
const Builder = require('./callbackBuilder');
const Utils = require('./utils');
const InstrumentationUtils = require('../../instrumentation/utils');
const Features = require('../../command/features');
const Config = require('../../config');

const WAF_METRICS = require('../../enums/metrics').PERF.WAF;

let LibSqreen;

const DEFAULT_MAX_TIMEOUT = 5; // ms
const MAX_TOP_RULE_RUNTIME_LENGTH = 20;

const getBaAndTransformerName = module.exports.getBaAndTransformerName = function (key) {

    const pipePos = key.lastIndexOf('|');
    if (pipePos === -1) {
        return { ba: key, transformer: '', key };
    }
    return { ba: key.slice(0, pipePos).trim(), transformer: key.slice(pipePos + 1).trim(), key };
};

//$lab:coverage:off$
// FIXME: must be covered with a mock available for situations where WAF is not present. Anyway, we support windows now!!
let first = true;
module.exports.getCbs = function (rule) {

    require('../reactive-callbacks/libSqreenCB').canLoadNative(); // check if native can be loaded
    try {
        LibSqreen = require('sq-native');
    }
    catch (e) {
        if (first) { // nocover
            Logger.DEBUG('Sqreen could not load package `sq-native`. In-app WAF features will not be available.');
            let Message;
            if (require('../../command/features').featureHolder.use_signals === true) {
                Message = require('../../agent_message');
            }
            else {
                Message = require('../../../lib_old/agent_message');
            }
            const Os = require('os');
            const infos = {
                platform: Os.platform(),
                arch: Os.arch(),
                node: process.version
            };
            const msg = 'Sqreen could not load package `sq-native`.\nIn-app WAF features will not be available.\nMessage: ' + e.message;
            (new Message(Message.KIND.no_sq_native, msg, infos))
                .report()
                .catch(() => {});
        }
        first = false;
        throw e;
    }

    // check rule is properly formed
    const opt = rule.data.values;
    const max_budget = opt.max_budget_ms || DEFAULT_MAX_TIMEOUT;
    const binding_accessors = opt.binding_accessors // we split bas and their transformers to resolve separately
        .map((x) => {

            if (typeof x === 'string') {
                return getBaAndTransformerName(x);
            }
            const res = getBaAndTransformerName(x.ba);
            res.default = x.default;
            return res;
        });

    const waf_rules = opt.waf_rules;
    const inst = new LibSqreen(UUID.v4(), waf_rules);

    const run = function (args, value, _, selfObject, session) {

        const req = session.req;
        const topSpan = session.topSpan;
        if (!req || (Fuzzer.hasFuzzer() && Fuzzer.isRequestReplayed(req))) {
            return null;
        }
        const params = {};
        const cache = new Map();
        for (let i = 0; i < binding_accessors.length; ++i) {
            const ba = binding_accessors[i].ba;
            const baKey = binding_accessors[i].key;
            const def = binding_accessors[i].default;
            const transformer = binding_accessors[i].transformer;

            const inCache = cache.has(ba); // cache, just in case
            let res;
            if (inCache === true) { // nocover
                res = cache.get(ba); // nocover
            }
            else {
                try {
                    res = Builder.bindThis.apply({ data: {} }, [ba, {}, {}, {}, req, req, topSpan]);
                }
                catch (__) {}
                if (res === null || res === undefined) {
                    res = def;
                }
                cache.set(ba, res);
            }
            if (res !== null && res !== undefined) { // no else, we will not bind empty things // nocover
                /**
                 * We need to:
                 * * apply the transformer
                 * * sanitize the object
                 */
                if (transformer !== 'flat_keys' && transformer !== 'flat_values') {
                    const t = Builder.transformers[transformer];
                    if (t !== undefined) {
                        params[baKey] = t(res);
                        res = params[baKey];
                    }
                }
                if (transformer === 'flat_keys') {
                    params[baKey] = Utils.flat_keys(res, 0);
                }
                else if (transformer === 'flat_values') {
                    params[baKey] = Utils.flat_values(res, 0);
                }
                else {
                    params[baKey] = Utils.limitObject(res, 0);
                }
            }
        }

        return params;
    };

    const sandbox = { run, result: null };
    const context = VM.createContext(sandbox);
    const Script = new VM.Script('result = run(args, value, _, selfObject, session, timeout);');

    return {
        pre: function (args, value, _, selfObject, session, timeout) { // todo: runInContext

            // timeout is always a number and can ba Infinity - see patch.js

            const tStart = process.hrtime();
            let params;
            timeout = Math.max(timeout, 1); // we need at least 1 ms
            if (timeout !== Infinity) {

                sandbox.args = args;
                sandbox.value = value;
                sandbox._ = _;
                sandbox.selfObject = selfObject;
                sandbox.session = session;
                sandbox.timeout = timeout;
                try {
                    Script.runInContext(context, { timeout: Math.ceil(timeout) }); // this only accepts integers in ms
                }
                catch (err) {
                    if (!err){ // nocover
                        throw new Error('empty err'); // nocover
                    }
                    if (err.message && err.message.indexOf('Script execution timed out') > -1) { // nocover
                        return null; // nocover
                    }
                    throw err; // nocover
                }

                params = sandbox.result;
            } // we have a timeout, no need to run in context
            else {
                params = run(args, value, _, selfObject, session, timeout);
            }

            if (params === null) { // this is a timeout situation
                return null;
            }

            const tSpent = process.hrtime(tStart);
            const spentTime = InstrumentationUtils.mergeHrtime(tSpent);
            timeout = timeout  - spentTime;

            if (timeout <= 0)  {
                return null;
            }

            timeout = Math.min(timeout, max_budget);
            const res = inst.run(params, timeout * 1000); // microsecond

            if (rule.block !== true) {
                res.status = null;
            }

            // We will write metrics only over signals
            if (Features.featureHolder.use_signals === true) {
                const date = new Date();
                const Metrics = require('../../metric');
                if (res.perfTotalRuntime !== undefined) {
                    // number
                    Metrics.addBinningObservation(WAF_METRICS.FULL, res.perfTotalRuntime, date);
                }
                if (res.perfCacheHitRate !== undefined) {
                    Metrics.addBinningObservation(WAF_METRICS.CACHE_HIT_RATE, res.perfCacheHitRate, date);
                }
                if (res.perfData !== undefined) {
                    const topRuleRuntime = res.perfData.topRuleRuntime;
                    const ln = Math.min(topRuleRuntime.length, MAX_TOP_RULE_RUNTIME_LENGTH);
                    for (let i = 0; i < ln; ++i) {
                        const k = topRuleRuntime[i][0];
                        const v = topRuleRuntime[i][1];
                        Metrics.addBinningObservation(`${WAF_METRICS.RULE_PREFIX}${k}`, v, date);
                    }
                }
            }

            return res;
        }
    };
};

module.exports.clearAll = function () {

    if (!Config.getConfig().libsqreen) {
        return true; // always true
    }

    try {
        require('sq-native').clearAll();
        return true;
    }
    catch (e) {
        return false; // nocover
    }
};
//$lab:coverage:on$
