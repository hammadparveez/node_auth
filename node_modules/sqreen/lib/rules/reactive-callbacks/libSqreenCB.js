/**
 * Copyright (c) 2016 - 2021 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const UUID = require('uuid');
const Config = require('../../config');
const ReactiveCB = require('./reactiveCB');

const Engine = require('../../engine');
const Logger = require('../../logger');
const Fuzzer = require('../../fuzzer');
const Features = require('../../command/features');
const WAF_METRICS = require('../../enums/metrics').PERF.WAF;

const DEFAULT_MAX_TIMEOUT = 5; // ms
const MAX_TOP_RULE_RUNTIME_LENGTH = 20;

const LibSqreenCB = module.exports = class extends ReactiveCB {

    static canLoadNative() {

        const config = Config.getConfig();
        if (!config.libsqreen) { // LibSqreen is disabled
            const msg = 'Sqreen could not load package as it was disabled by agent configuration';
            const err = new Error(msg);
            err.noReport = true;
            throw err;
        }
    }

    static init() {

        LibSqreenCB.canLoadNative();
        try {
            LibSqreenCB.LibSqreen = require('sq-native');
        }
        catch (e) {
            if (LibSqreenCB.hasNotInit === false) {
                throw e;
            }
            LibSqreenCB.hasNotInit = false;

            Logger.DEBUG('Sqreen could not load package `sq-native`. In-app WAF features will not be available.');
            let Message;
            if (require('../../command/features').featureHolder.use_signals === true) {
                Message = require('../../agent_message');
            }
            else {
                Message = require('../../../lib_old/agent_message');
            }
            const Os = require('os');
            const infos = {
                platform: Os.platform(),
                arch: Os.arch(),
                node: process.version
            };
            const msg = 'Sqreen could not load package `sq-native`.\nIn-app WAF features will not be available.\nMessage: ' + e.message;
            (new Message(Message.KIND.no_sq_native, msg, infos))
                .report()
                .catch(() => {});
            throw e;
        }
    }

    // TODO: make the other callback use this too
    static handleResult(rule, res) {

        if (rule.block !== true) {
            res.status = null;
        }

        // We will write metrics only over signals
        if (Features.featureHolder.use_signals === true) {
            const date = new Date();
            const Metrics = require('../../metric');
            if (res.perfTotalRuntime !== undefined) {
                // number
                Metrics.addBinningObservation(WAF_METRICS.FULL, res.perfTotalRuntime, date);
            }
            if (res.perfCacheHitRate !== undefined) {
                Metrics.addBinningObservation(WAF_METRICS.CACHE_HIT_RATE, res.perfCacheHitRate, date);
            }
            if (res.perfData !== undefined) {
                const topRuleRuntime = res.perfData.topRuleRuntime;
                const ln = Math.min(topRuleRuntime.length, MAX_TOP_RULE_RUNTIME_LENGTH);
                for (let i = 0; i < ln; ++i) {
                    const k = topRuleRuntime[i][0];
                    const v = topRuleRuntime[i][1];
                    Metrics.addBinningObservation(`${WAF_METRICS.RULE_PREFIX}${k}`, v, date);
                }
            }
        }

        return res;
    }

    constructor(rule) {

        super(rule);

        LibSqreenCB.init();

        // weak cache must be per instanciation of the callback
        // as we might have 2 different rules (one test one not)
        this.weakCache = new WeakMap();

        const opt = rule.data.values;
        const waf_rules = opt.waf_rules;
        const subscriptionList = opt.rule_request;
        this.max_budget = opt.max_budget_ms || DEFAULT_MAX_TIMEOUT;
        this.instance = new LibSqreenCB.LibSqreen(UUID.v4(), waf_rules);

        const subscription = this.getSubscription(rule);

        for (let i = 0; i < subscriptionList.length; ++i) {
            Engine.subscribe(subscriptionList[i], subscription);
        }
    }

    action(args, value, rule, selfObject, session, timeout) {

        const req = session.req; // Do not spread the Fuzzer calls
        //$lab:coverage:off$
        if (!req || (Fuzzer.hasFuzzer() && Fuzzer.isRequestReplayed(req))) {
            return null;
        }
        //$lab:coverage:on$

        const actualTimeout = Math.min(timeout, this.max_budget);

        let additiveInstanceHolder = this.weakCache.get(req);
        if (additiveInstanceHolder === undefined) {
            additiveInstanceHolder = {
                instance: this.instance.startAdditive(),
                cache: {}
            };
            this.weakCache.set(req, additiveInstanceHolder);
            session.cleanup.push(() => {

                additiveInstanceHolder.instance.dispose();
                additiveInstanceHolder.cache = {};
            });
        }
        const additiveInstance = additiveInstanceHolder.instance;
        if (additiveInstance.finished === true) {
            return null; // TODO: something? throw an exception?
        }

        const cache = additiveInstanceHolder.cache;
        const argsKeys = Object.keys(args);
        const params = {};

        for (let i = 0; i < argsKeys.length; ++i) {
            const key = argsKeys[i];
            const cacheValue = cache[key];
            const argsValue = args[key];
            if (this.allAddresses.has(key) && cacheValue !== argsValue) {
                params[key] = argsValue;
                cache[key] = argsValue;
            }
        }

        if (Object.keys(params).length === 0) {
            return {};
        }

        const res = additiveInstance.run(params, actualTimeout * 1000); // microsecond
        return LibSqreenCB.handleResult(rule, res);
    }
};
LibSqreenCB.hasNotInit = true;
