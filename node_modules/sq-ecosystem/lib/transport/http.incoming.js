/**
 * Copyright (c) 2016 - 2020 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const UuidV4 = require('uuid/v4');
const OnFinished = require('on-finished');
const Busboy = require('busboy');
const INTERFACES = require('../enums').INTERFACES;
const TRANSPORT = require('../enums').TRANSPORT;
const HEADERS = require('../enums').HEADERS;
const Transports = require('../transports');

const RAW_BODY_MAX_LENGTH = 1024;
const BODY_METHODS = ['POST', 'PUT', 'PATCH'];

const isEmitter = function (emitter) {

    return !!(emitter && emitter.on && emitter.addListener && emitter.emit);
};

const cleanup = function (transport, req, res, record, budgetSum, budget, monitBudget, session, holder) {

    transport.stopIncomingTransaction(req, () => {

        req.__sqreen = undefined;
        req.__sqreen_lookable = undefined;
        req.__sqreen_res = undefined;
        req.__sqreen_url = undefined;

        if (record) {
            session.run(() => {

                session.set('req', req);
                session.set('res', res);
                holder.end.apply(res, [req]);
                transport.stopHttpTransaction(req, res, record, budgetSum, budget, monitBudget); // FIXME: kill all spans here!!
            });
        }
    });
};

const FILE_FIELDS = ['server.request.body.files_field_names', 'server.request.body.filenames', 'server.request.body.combined_file_size'];

const lazyListen = function (emitter, targetEvent, listener) {

    const handler = function (event) {

        if (targetEvent === event) {
            emitter.removeListener('newListener', handler); // do not place interceptor listener more than once
            emitter.on(targetEvent, listener);
        }
    };
    emitter.on('newListener', handler);
};

const addStringUpTo = function (base, toAdd, maxLen) {

    const sum = base.length + toAdd.length;
    if (sum > maxLen) {
        return base + toAdd.slice(0, maxLen - sum);
    }
    return base + toAdd;
};

/**
 *
 * @param {Set<string>} set
 * @return {Set<string>}
 */
const getFileAddresses = function (set) {

    const res = new Set();
    for (let i = 0; i < FILE_FIELDS.length; ++i) {
        if (set.has(FILE_FIELDS[i]) === true) {
            res.add(FILE_FIELDS[i]);
        }
    }
    return res;
};

/**
 *
 * @param {Set<string>} set
 * @param {http.IncomingMessage} req
 * @param {any} transport
 */
const setupFileHandling = function (set, req, transport) {

    if (BODY_METHODS.indexOf(req.method) < 0) {
        return;
    }
    const fields = getFileAddresses(set);
    if (fields.size === 0) {
        return;
    }

    let busboy;
    try {
        busboy = new Busboy({ headers: req.headers });
    }
    catch (_) {
        return;
    }
    const collectFileSize = set.has('server.request.body.combined_file_size');
    const results = {
        filenames: [],
        fields: [],
        combined_file_size: 0
    };
    busboy.on('file', (fieldName, file, filename) => {

        results.filenames.push(filename);
        results.fields.push(fieldName);
        if (collectFileSize === true) {
            file.on('data', (data) => {

                results.combined_file_size += data.length;
            });
        }
    });
    const onData = function (c) {

        busboy.write(c);
    };
    req.on('end', () => {

        req.removeListener('data', onData);
        const resolved = {};
        if (collectFileSize === true) {
            resolved['server.request.body.combined_file_size'] = results.combined_file_size;
        }
        if (set.has('server.request.body.filenames') === true) {
            resolved['server.request.body.filenames'] = results.filenames;
        }
        if (set.has('server.request.body.files_field_names') === true) {
            resolved['server.request.body.files_field_names'] = results.fields;
        }
        transport.propagate(resolved, null, true);
    });
    lazyListen(req, 'data', onData);
};

/**
 * @param payload {{module: any, identity: any}}
 * @param ecoSystemInterface
 */
module.exports = function (payload, ecoSystemInterface) {

    const module = payload.module;
    const identity = payload.identity;

    const instrumentation = ecoSystemInterface.getInterface(INTERFACES.INSTRUMENTATION);
    const transport = ecoSystemInterface.getInterface(INTERFACES.TRANSPORT);
    const engine = ecoSystemInterface.getInterface(INTERFACES.ENGINE);

    transport.enableHTTP();

    const utils = transport.utils;
    const ipAndPath = transport.ipAndPath;
    const checkIPandPath = ipAndPath.checkIPandPath;
    const ipPathAction = ipAndPath.ACTIONS;
    const Server = module.Server;

    // we want 1 instance of this per call so we can have 1 for http and another one for https
    const holder = {
        end: function () {
        },
        request: function (ip) {

            return true;
        },
        request_second_hook: function () {

            return true;
        }
    };
    const getHook = function (server, listener) {

        instrumentation.registerHttpServerForReveal(server);

        return function (req, res) {

            if (!isEmitter(req) || !isEmitter(res)) {
                return listener.apply(this, arguments);
            }
            transport.startIncomingTransaction(req, (session, budget, monitBudget) => { // TODO: abstract in agent

                budget.startCount();
                req.__sqreen_url = req.url;
                req.__sqreen_res = res;
                res.__original_end = res.end;
                req.__sqreen_uuid = UuidV4();

                session.bindEmitter(req);
                session.bindEmitter(res);

                session.set('req', req);
                session.set('res', res);
                const ipAddress = utils.ensureProperIP(utils.getXFFOrRemoteAddress(req)) || '';

                const neededFieldSet = engine.getNeededFieldSet();

                // prevent double writing if request was sqreen_dropped
                // see rule-callback/utils.js:11
                const write = res.write;
                const end = res.end;
                const getOutputBody = neededFieldSet.has('server.response.body.raw');
                let responseBody = '';
                let resPropagated = false;
                let endCalled = false;

                const handleChunk = function (chunk) {

                    if (getOutputBody === true && resPropagated === false) {
                        if (chunk instanceof Buffer) {
                            responseBody = addStringUpTo(responseBody, chunk.toString(), RAW_BODY_MAX_LENGTH);
                        }
                        else if (typeof chunk === 'string') {
                            responseBody = addStringUpTo(responseBody, chunk, RAW_BODY_MAX_LENGTH);
                        }
                        if (responseBody.length >= RAW_BODY_MAX_LENGTH) {
                            resPropagated = true;
                            transport.propagate({ 'server.response.body.raw': responseBody }, null, false);
                        }
                    }
                };

                res.end = function (chunk) {

                    endCalled = true;
                    handleChunk(chunk);
                    return end.apply(this, arguments);
                };

                res.write = function (chunk) { // TODO: patch on prototype

                    if (!this.__sqreen_finisehd) {
                        // in Node < 8 res.end(chunk) will call res.write(chunk), let's not handleChunk twice
                        //$lab:coverage:off$
                        if (endCalled === false) {
                        //$lab:coverage:on$
                            handleChunk(chunk);
                        }

                        return write.apply(this, arguments);
                    }
                };

                const record = transport.getHttpTrace(req, ipAddress);

                const finish = function () {

                    if (req.__sq_finished === true) {
                        return;
                    }
                    req.__sq_finished = true;

                    if (resPropagated === false && getOutputBody === true) {
                        resPropagated = true;
                        transport.propagate({ 'server.response.body.raw': responseBody }, null, false);
                    }
                    if (neededFieldSet.has('server.response.status') === true) {
                        transport.propagate({ 'server.response.status': res.statusCode }, null, false);
                    }
                    cleanup(transport, req, res, record, budget.sum, budget, monitBudget, session, holder);
                };

                OnFinished(res, finish); // TODO: mutex someday
                res.on('finish', finish);

                if (checkIPandPath(ipAddress, req, res) === ipPathAction.PREVENT) {
                    return; // do not let this go through
                }

                const toPropagate = transport.shouldPropagate(TRANSPORT.SCOPE.HTTP.INCOMING);
                const trigger = toPropagate.trigger;

                const resolved = new Transports.ServerTransport(); // We collect everything all the time to make sure RASP will work
                // Eventually when RASP is moved over the engine, we might reconsider
                resolved['server.request.method'] = req.method;
                resolved['server.request.tracing_identifier'] = req.headers[HEADERS.X_SQREEN_TRACKING] || '';
                resolved['server.request.headers.no_cookies'] = Object.assign({}, req.headers);
                delete resolved['server.request.headers.no_cookies'].cookie;
                resolved['server.request.uri.raw'] = req.url; // TODO: check if hostname can be there
                resolved['server.request.client_ip'] = ipAddress;
                resolved['server.request.transport'] = TRANSPORT.TRANSPORT_TYPE.HTTP;
                transport.propagate(resolved, trigger, true);

                if (neededFieldSet.has('server.request.body.raw')) {
                    const arr = [];
                    let len = 0;
                    let hasFinishReqRawBodyEmit = false;
                    const finishReqRawBodyEmit = function () {

                        if (hasFinishReqRawBodyEmit === true) {
                            return;
                        }
                        hasFinishReqRawBodyEmit = true;
                        const body = Buffer.concat(arr).toString(); // FIXME: this is weirdly asynchronous. no way you'll get the cleanup function
                        transport.propagate({ 'server.request.body.raw': body }, null, true); // TODO: don't propagate response already emitted?
                    };
                    // Gotcha: will only block with synchronous blocking
                    const handler = function (chunk) {

                        const cl = chunk.length;
                        if (len <= RAW_BODY_MAX_LENGTH && hasFinishReqRawBodyEmit === false) {
                            const diff = RAW_BODY_MAX_LENGTH - (len + cl);
                            if (diff < 0) {
                                chunk = chunk.slice(0, diff);
                            }
                            arr.push(chunk);
                            len += cl;
                        }
                        else {
                            req.removeListener('data', handler); // remove listener
                            finishReqRawBodyEmit();
                        }
                    };
                    lazyListen(req, 'data', handler);
                    req.on('end', () => {

                        finishReqRawBodyEmit();
                    });
                }

                setupFileHandling(neededFieldSet, req, transport);

                if (holder.request(ipAddress, req, res)) {
                    if (req._sqreen_ip_whitelist || holder.request_second_hook('request', req, res)) {
                        budget.stopCount();
                        return listener.apply(this, arguments);
                    }
                }
            });
        };
    };

    instrumentation.strategies.patchFunction(holder, 'end', identity, 'ServerResponse.on');
    instrumentation.strategies.patchFunction(holder, 'request', identity, 'Server.on');
    instrumentation.strategies.patchFunction(holder, 'request_second_hook', identity, 'Server.on');

    instrumentation.strategies.patchEventListeners(Server.prototype, 'request', getHook);
};
module.exports.isEmitter = isEmitter;
module.exports._cleanup = cleanup;
