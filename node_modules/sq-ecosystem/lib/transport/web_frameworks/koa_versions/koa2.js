/**
 * Copyright (c) 2016 - 2020 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';

const Shimmer = require('shimmer');
const INTERFACES = require('../../../enums').INTERFACES;
const HTTP = require('../../commons/addresses').HTTP;
const Util = require('../../../util');

module.exports = function (payload, ecoSystemInterface) {

    const transport = ecoSystemInterface.getInterface(INTERFACES.TRANSPORT);

    if (payload.request === 'koa') {
        const middleware = function emitQuery(ctx, next) {

            Util.emitIFNeeded(HTTP.HTTP_REQUEST_QUERY, ctx.request.query, true);

            return next();
        };

        const onError = function (err, ctx) {

            // should be called if user has a custom error handler before ctx.onerror
            transport.sqreenBlocking(err, ctx.req, ctx.res);
        };

        Shimmer.wrap(payload.module.prototype, 'callback', (callback) => {

            return function wrappedCallback() {

                if (this.middleware[0] !== middleware) {
                    this.middleware.unshift(middleware);
                }

                if (this.listeners('error')[0] !== onError) {
                    this.prependListener('error', onError);
                }

                return callback.apply(this, arguments);
            };
        });
    }
    else if (payload.request === './context') {

        const engine = ecoSystemInterface.getInterface(INTERFACES.ENGINE);

        Shimmer.wrap(payload.module, 'onerror', (onerror) => {

            return function wrappedOnerror(err) {

                if (err) {
                    // will be called if an exception goes all the way upstream
                    const shouldBlock = transport.sqreenBlocking(err, this.req, this.res);

                    if (shouldBlock) {
                        return;
                    }
                }

                return onerror.apply(this, arguments);
            };
        });

        const wrapGet = function (get) {

            return function wrappedGet(name) {

                const cookie = get.apply(this, arguments);

                if (cookie) {
                    const requestCookies = engine.resolveAddress(HTTP.HTTP_REQUEST_COOKIES) || {};

                    requestCookies[name] = cookie;

                    transport.propagate({ [HTTP.HTTP_REQUEST_COOKIES]: requestCookies }, null, true);
                }

                return cookie;
            };
        };

        const originalGetter = Object.getOwnPropertyDescriptor(payload.module, 'cookies').get;

        const wrappedGetter = function () {

            const cookies = originalGetter.apply(this, arguments);

            if (engine.getNeededFieldSet().has(HTTP.HTTP_REQUEST_COOKIES) === true) {
                Shimmer.wrap(cookies, 'get', wrapGet);
            }

            // restore original getter as we only want to wrap cookies.get once per request
            wrappedGetter.__unwrap();

            return cookies;
        };

        wrappedGetter.__unwrap = function () {

            Object.defineProperty(payload.module, 'cookies', {
                get: originalGetter
            });
        };

        Object.defineProperty(payload.module, 'cookies', {
            get: wrappedGetter
        });
    }
};
