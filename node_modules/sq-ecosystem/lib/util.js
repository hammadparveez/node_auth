/**
 * Copyright (c) 2016 - 2020 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const EcosystemInterfaceHolder = require('./interfaces');
const INTERFACE = require('./enums').INTERFACES;

module.exports.emitIFNeeded = function (address, value, isTopSpan) {

    if (EcosystemInterfaceHolder.ecosystemInterface.getInterface(INTERFACE.ENGINE).getNeededFieldSet().has(address) === true) {
        EcosystemInterfaceHolder.ecosystemInterface.getInterface(INTERFACE.TRANSPORT).propagate({ [address]: value }, null, isTopSpan);
    }
};

module.exports.multipleEmitIFNeeded = function (data, isTopSpan) {

    const neededFieldSet = EcosystemInterfaceHolder.ecosystemInterface.getInterface(INTERFACE.ENGINE).getNeededFieldSet();
    const result = {};
    let emit = false;
    const addressList = Object.keys(data);
    for (let i = 0; i < addressList.length; ++i) {
        const add = addressList[i];
        if (neededFieldSet.has(add) === true) {
            result[add] = data[add];
            emit = true;
        }
    }
    if (emit === true) {
        EcosystemInterfaceHolder.ecosystemInterface.getInterface(INTERFACE.TRANSPORT).propagate(result, null, isTopSpan);
    }
};

// TODO: trim all
const parseLine = function (line) {

    const equal = line.split('=').map((x) => x.trim());
    if (equal.length !== 2) {
        throw new Error(`no '=' character in ${line}`);
    }
    const keyPath = equal[0].split('.').map((x) => x.trim());
    const value = equal[1] === '1' || equal[1] === 'true';
    return { keyPath, value, line: equal[0] };
};

module.exports.updateManifest = function (manifest, updateString, logger) {

    if (!updateString) {
        return manifest;
    }

    const rawLines = updateString.split(',').map((x) => x.trim());
    for (let i = 0; i < rawLines.length; ++i) {
        const currentRawLine = rawLines[i];
        try {
            const line = parseLine(currentRawLine);
            const arr = Array.from(line.keyPath);
            const key = arr.pop();
            let curr = manifest;
            for (let j = 0; j < arr.length; ++j) {
                curr = curr[arr[j]];
                if (typeof curr !== 'object' || curr === null) {
                    throw new Error(`no path ${line.line} in manifest - line is ignored`);
                }
            }
            if (typeof curr[key] !== 'boolean') {
                throw new Error(`${line.line} is not a full path in manifest`);
            }
            curr[key] = line.value;
        }
        catch (e) {
            logger.ERROR(`could not parse line ${currentRawLine}:`);
            logger.ERROR(e.message);
        }
    }
    return manifest;
};
