/**
 * Copyright (c) 2016 - 2021 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();

const Semver = require('semver');

if (Semver.satisfies(process.version, '<8.x')) {
    return;
}

const describe = lab.describe;
const beforeEach = lab.beforeEach;
const it = lab.it;
const expect = Code.expect;

const SuperTest = require('supertest');
const Hook = require('../../../../../lib/transport/web_frameworks/koa_versions/koa_modules/koa-compose');
const kIsBodyParser = require('../../../../../lib/transport/web_frameworks/koa_versions/common').kIsBodyParser;
const getEcosystemMock = require('../../../../test_utils').getEcosystemMock;
const INTERFACES = require('../../../../../lib/enums').INTERFACES;

const BodyParser = require('koa-bodyparser');

const getWrapped = function (iFace) {

    let result;

    iFace[INTERFACES.INSTRUMENTATION].setWrapCallback = function (name, cb) {

        expect(name).to.equal('koa-compose');
        result = cb((middlewares) => middlewares);
    };

    Hook.enable(iFace);

    return result;
};

const printIfError = function (r) {

    if (r.statusCode !== 200) {
        console.log(r.text);
    }
};

describe('koa-compose', () => {

    beforeEach((done) => {

        delete require.cache[require.resolve('koa')];
        delete require.cache[require.resolve('koa-compose')];
        delete require.cache[require.resolve('@koa/router')];

        done();
    });

    it('should not do anything', { plan: 5 }, (done) => {

        const iFace = getEcosystemMock();

        const wrapped = getWrapped(iFace);

        const middlewares = [
            function test1() {},
            function test2() {},
            function test3() {}
        ];

        const results = wrapped(middlewares);

        expect(results).to.have.length(3);
        expect(results[0].name).to.equal('test1');
        expect(results[1].name).to.equal('test2');
        expect(results[2].name).to.equal('test3');

        done();
    });

    it('should add body emit after kBodyParser', { plan: 6 }, (done) => {

        const iFace = getEcosystemMock();

        const wrapped = getWrapped(iFace);

        const middlewares = [
            function test1() {},
            function weirdbodyparser() {},
            function test3() {}
        ];

        middlewares[1][kIsBodyParser] = true;

        const results = wrapped(middlewares);

        expect(results).to.have.length(4);
        expect(results[0].name).to.equal('test1');
        expect(results[1].name).to.equal('weirdbodyparser');
        expect(results[2].name).to.equal('bodyEmit');
        expect(results[3].name).to.equal('test3');

        done();
    });

    it('should add body emit after bodyParser', { plan: 6 }, (done) => {

        const iFace = getEcosystemMock();

        const wrapped = getWrapped(iFace);

        const middlewares = [
            function test1() {},
            function bodyParser() {},
            function test3() {}
        ];

        const results = wrapped(middlewares);

        expect(results).to.have.length(4);
        expect(results[0].name).to.equal('test1');
        expect(results[1].name).to.equal('bodyParser');
        expect(results[2].name).to.equal('bodyEmit');
        expect(results[3].name).to.equal('test3');

        done();
    });

    it('should wrap dispatch', { plan: 5 }, (done) => {

        const iFace = getEcosystemMock();

        const wrapped = getWrapped(iFace);

        const middlewares = [
            function test1() {},
            function dispatch() {},
            function test3() {}
        ];

        const results = wrapped(middlewares);

        expect(results).to.have.length(3);
        expect(results[0].name).to.equal('test1');
        expect(results[1].name).to.equal('wrappedDispatch');
        expect(results[2].name).to.equal('test3');

        done();
    });

    it('should emit body', { plan: 6 }, (done) => {

        const iFace = getEcosystemMock();

        iFace[INTERFACES.INSTRUMENTATION].setWrapCallback = function (name, cb) {

            expect(name).to.equal('koa-compose');

            const result = cb(require('koa-compose'));

            require.cache[require.resolve('koa-compose')].exports = result;

            return result;
        };

        iFace[INTERFACES.ENGINE].getNeededFieldSet = function () {

            return {
                has: () => true
            };
        };

        const propagated = [];
        iFace[INTERFACES.TRANSPORT].propagate = function (val, _, bool) {

            expect(bool).to.be.true();
            propagated.push(val);
        };

        Hook.enable(iFace);

        const Koa = require('koa');

        const app = new Koa();

        app.use(BodyParser());

        app.use((ctx, next) => {

            expect(ctx.request.body).to.equal({ a: '1', b: '2' });
            ctx.status = 200;
            return next();
        });

        SuperTest(app.callback())
            .post('/')
            .send('a=1&b=2')
            .then((r) => {

                printIfError(r);
                expect(r.statusCode).to.equal(200);

                expect(propagated).to.have.length(1);
                expect(propagated[0]).to.equal({ 'server.request.body': { a: '1', b: '2' } });

                done();
            });
    });

    it('should emit router adresses', { plan: 6 }, (done) => {

        const iFace = getEcosystemMock();

        iFace[INTERFACES.INSTRUMENTATION].setWrapCallback = function (name, cb) {

            expect(name).to.equal('koa-compose');

            const result = cb(require('koa-compose'));

            require.cache[require.resolve('koa-compose')].exports = result;

            return result;
        };

        iFace[INTERFACES.ENGINE].getNeededFieldSet = function () {

            return {
                has: () => true
            };
        };

        const propagated = [];
        iFace[INTERFACES.TRANSPORT].propagate = function (val, _, bool) {

            expect(bool).to.be.true();
            propagated.push(val);
        };

        Hook.enable(iFace);

        const compose = require('koa-compose');

        const checkCompose = function () {

            const middlewares = [
                function test1(ctx, next) {

                    return next();
                },
                function test2(ctx, next) {

                    return next();
                },
                function test3(ctx, next) {

                    return next();
                }
            ];

            const result = compose(middlewares);

            result({});
        };

        const Koa = require('koa');
        const Router = require('@koa/router');

        const app = new Koa();
        const router = new Router();

        checkCompose();

        router.get('/a/:param/:anotherParam', (ctx, next) => {

            expect(ctx.params).to.equal({ param: '10', anotherParam: 'abc' });

            checkCompose();
            ctx.status = 200;
            return next();
        });

        checkCompose();

        app.use((ctx, next) => {

            checkCompose();
            return next();
        });

        app.use(router.routes());

        app.use((ctx, next) => {

            checkCompose();
            return next();
        });

        checkCompose();

        SuperTest(app.callback())
            .get('/a/10/abc')
            .then((r) => {

                printIfError(r);
                expect(r.statusCode).to.equal(200);

                expect(propagated).to.have.length(1);
                expect(propagated[0]).to.equal({
                    'server.request.path_params': { param: '10', anotherParam: 'abc' },
                    'server.request.framework_endpoint': '/a/:param/:anotherParam'
                });

                done();
            });
    });

    it('should stop router mode when no route is matched', { plan: 2 }, (done) => {

        const iFace = getEcosystemMock();

        iFace[INTERFACES.INSTRUMENTATION].setWrapCallback = function (name, cb) {

            expect(name).to.equal('koa-compose');

            const result = cb(require('koa-compose'));

            require.cache[require.resolve('koa-compose')].exports = result;

            return result;
        };

        iFace[INTERFACES.ENGINE].getNeededFieldSet = function () {

            return {
                has: () => true
            };
        };

        iFace[INTERFACES.TRANSPORT].propagate = function () {

            throw new Error('shouldnotbecalled');
        };

        Hook.enable(iFace);

        const compose = require('koa-compose');

        const checkCompose = function () {

            const middlewares = [
                function test1(ctx, next) {

                    return next();
                },
                function test2(ctx, next) {

                    return next();
                },
                function test3(ctx, next) {

                    return next();
                }
            ];

            const result = compose(middlewares);

            result({});
        };

        const Koa = require('koa');
        const Router = require('@koa/router');

        const app = new Koa();
        const router = new Router();

        checkCompose();

        app.use((ctx, next) => {

            checkCompose();
            return next();
        });

        app.use(router.routes());

        app.use((ctx, next) => {

            checkCompose();
            return next();
        });

        checkCompose();

        SuperTest(app.callback())
            .get('/notfound')
            .then((r) => {

                expect(r.statusCode).to.equal(404);

                done();
            });
    });
});
