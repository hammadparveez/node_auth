/**
 * Copyright (c) 2016 - 2021 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();

const Semver = require('semver');

if (Semver.satisfies(process.version, '<8.x')) {
    return;
}

const describe = lab.describe;
const beforeEach = lab.beforeEach;
const it = lab.it;
const expect = Code.expect;

const Shimmer = require('shimmer');
const SuperTest = require('supertest');
const KoaGlobalHook = require('../../../../../lib/transport/web_frameworks/koa');
const KoaHook = require('../../../../../lib/transport/web_frameworks/koa_versions/koa2');
const INTERFACES = require('../../../../../lib/enums').INTERFACES;
const getEcosystemMock = require('../../../../test_utils').getEcosystemMock;

const Koa = require('koa');
const Context = require('koa/lib/context');
const JsonError = require('koa-json-error');

const getApp = function (iFace) {

    KoaHook({ request: 'koa', module: Koa }, iFace);
    KoaHook({ request: './context', module: Context }, iFace);

    return new Koa();
};

const unpatchKoa = function () {

    if (typeof Koa.prototype.callback.__unwrap === 'function') {
        Koa.prototype.callback.__unwrap();
    }

    if (typeof Context.onerror.__unwrap === 'function') {
        Context.onerror.__unwrap();

        // sometimes we wrap it twice
        if (typeof Context.onerror.__unwrap === 'function') {
            Context.onerror.__unwrap();
        }
    }

    const prop = Object.getOwnPropertyDescriptor(Context, 'cookies');
    if (prop && prop.get && typeof prop.get.__unwrap === 'function') {
        prop.get.__unwrap();
    }
};

const printIfError = function (r) {

    if (r.statusCode !== 200) {
        console.log(r.text);
    }
};

describe('Koa', () => {

    it('should cover dispatcher', { plan: 3 }, (done) => {

        const iFace = getEcosystemMock();

        KoaGlobalHook({ identity: { version: '99.13.4' }, request: 'koa', module: Koa }, iFace);

        expect(Koa.prototype.callback.name).to.equal('callback');

        KoaGlobalHook({ identity: { version: '2.13.4' }, request: 'not-koa', module: Koa }, iFace);

        expect(Koa.prototype.callback.name).to.equal('callback');

        KoaGlobalHook({ identity: { version: '2.13.4' }, request: 'koa', module: Koa }, iFace);

        expect(Koa.prototype.callback.name).to.equal('wrappedCallback');

        done();
    });
});

describe('Koa 2', () => {

    beforeEach((done) => {

        unpatchKoa();
        done();
    });

    it('should test koa with cookies', { plan: 10 }, (done) => {

        const iFace = getEcosystemMock();

        iFace[INTERFACES.ENGINE].getNeededFieldSet = function () {

            return {
                has: () => true
            };
        };

        const propagated = [];
        iFace[INTERFACES.TRANSPORT].propagate = function (val, _, bool) {

            expect(bool).to.be.true();
            propagated.push(val);
        };

        iFace[INTERFACES.ENGINE].resolveAddress = function (address) {

            for (let i = propagated.length - 1; i >= 0; --i) {
                if (propagated[i][address] !== undefined) {
                    return propagated[i][address];
                }
            }
        };

        const app = getApp(iFace);

        app.use((ctx, next) => {

            expect(ctx.cookies.get.name).to.equal('wrappedGet');
            expect(ctx.cookies.get('b')).to.equal('2');
            expect(ctx.cookies.get('c')).to.equal('3');

            ctx.status = 200;
            return next();
        });

        SuperTest(app.callback())
            .get('/a/10?q=hello')
            .set('Cookie', ['a=1', 'b=2', 'c=3'])
            .then((r) => {

                printIfError(r);
                expect(r.statusCode).to.equal(200);

                expect(propagated).to.have.length(3);
                expect(propagated[0]).to.equal({ 'server.request.query': { 'q': 'hello' } });
                expect(propagated[2]).to.equal({ 'server.request.cookies': { b: '2', c: '3' } });

                done();
            });
    });

    it('should test koa without cookie', { plan: 7 }, (done) => {

        const iFace = getEcosystemMock();

        iFace[INTERFACES.ENGINE].getNeededFieldSet = function () {

            return {
                has: (address) => address === 'server.request.query'
            };
        };

        const propagated = [];
        iFace[INTERFACES.TRANSPORT].propagate = function (val, _, bool) {

            expect(bool).to.be.true();
            propagated.push(val);
        };

        const app = getApp(iFace);

        app.use((ctx, next) => {

            expect(ctx.cookies.get.name).to.not.equal('wrappedGet');
            expect(ctx.cookies.get('b')).to.equal('2');
            expect(ctx.cookies.get('c')).to.equal('3');

            ctx.status = 200;
            return next();
        });

        SuperTest(app.callback())
            .get('/a/10?q=hello')
            .set('Cookie', ['a=1', 'b=2', 'c=3'])
            .then((r) => {

                printIfError(r);
                expect(r.statusCode).to.equal(200);

                expect(propagated).to.have.length(1);
                expect(propagated[0]).to.equal({ 'server.request.query': { 'q': 'hello' } });

                done();
            });
    });

    it('should test koa with empty cookie', { plan: 8 }, (done) => {

        const iFace = getEcosystemMock();

        iFace[INTERFACES.ENGINE].getNeededFieldSet = function () {

            return {
                has: () => true
            };
        };

        const propagated = [];
        iFace[INTERFACES.TRANSPORT].propagate = function (val, _, bool) {

            expect(bool).to.be.true();
            propagated.push(val);
        };

        iFace[INTERFACES.ENGINE].resolveAddress = function (address) {

            for (let i = propagated.length - 1; i >= 0; --i) {
                if (propagated[i][address] !== undefined) {
                    return propagated[i][address];
                }
            }
        };

        const app = getApp(iFace);

        app.use((ctx, next) => {

            expect(ctx.cookies.get('d')).to.equal(undefined);
            expect(ctx.cookies.get('c')).to.equal('3');

            ctx.status = 200;
            return next();
        });

        SuperTest(app.callback())
            .get('/a/10?q=hello')
            .set('Cookie', ['a=1', 'b=2', 'c=3'])
            .then((r) => {

                printIfError(r);
                expect(r.statusCode).to.equal(200);

                expect(propagated).to.have.length(2);
                expect(propagated[0]).to.equal({ 'server.request.query': { 'q': 'hello' } });
                expect(propagated[1]).to.equal({ 'server.request.cookies': { c: '3' } });

                done();
            });
    });

    it('should not inject middleware multiple times', { plan: 11 }, (done) => {

        const iFace = getEcosystemMock();

        iFace[INTERFACES.ENGINE].getNeededFieldSet = function () {

            return {
                has: () => true
            };
        };

        const propagated = [];
        iFace[INTERFACES.TRANSPORT].propagate = function (val, _, bool) {

            expect(bool).to.be.true();
            propagated.push(val);
        };

        iFace[INTERFACES.ENGINE].resolveAddress = function (address) {

            for (let i = propagated.length - 1; i >= 0; --i) {
                if (propagated[i][address] !== undefined) {
                    return propagated[i][address];
                }
            }
        };

        const app = getApp(iFace);

        app.use((ctx, next) => {

            expect(ctx.cookies.get('b')).to.equal('2');
            expect(ctx.cookies.get('c')).to.equal('3');

            ctx.status = 200;
            return next();
        });

        app.callback();

        SuperTest(app.callback())
            .get('/a/10?q=hello')
            .set('Cookie', ['a=1', 'b=2', 'c=3'])
            .then((r) => {

                printIfError(r);
                expect(r.statusCode).to.equal(200);

                expect(propagated).to.have.length(3);
                expect(propagated[0]).to.equal({ 'server.request.query': { 'q': 'hello' } });
                expect(propagated[2]).to.equal({ 'server.request.cookies': { b: '2', c: '3' } });

                expect(app.middleware).to.have.length(2);
                expect(app.listenerCount('error')).to.equal(1);

                done();
            });
    });

    it('should test koa with blocking', { plan: 6 }, (done) => {

        const iFace = getEcosystemMock();

        iFace[INTERFACES.TRANSPORT].sqreenBlocking = function (err, req, res) {

            expect(err.message).to.equal('Sqreen blocking Error');
            res.statusCode = 403;
            res.end('You have been blocked');
            return true;
        };

        iFace[INTERFACES.ENGINE].getNeededFieldSet = function () {

            return {
                has: () => true
            };
        };

        const propagated = [];
        iFace[INTERFACES.TRANSPORT].propagate = function (val, _, bool) {

            expect(bool).to.be.true();
            propagated.push(val);
            throw new Error('Sqreen blocking Error');
        };

        Shimmer.wrap(Context, 'onerror', (onerror) => {

            return function shouldNotBeCalled(err) {

                if (err) {
                    expect('should not be called').to.equal(true);
                }
                else {
                    return onerror.apply(this, arguments);
                }
            };
        });

        const app = getApp(iFace);

        app.use((ctx, next) => {

            expect('should not be called').to.equal(true);
        });

        SuperTest(app.callback())
            .get('/a/10?q=hello')
            .then((r) => {

                expect(r.statusCode).to.equal(403);
                expect(r.text).to.equal('You have been blocked');

                expect(propagated).to.have.length(1);
                expect(propagated[0]).to.equal({ 'server.request.query': { q: 'hello' } });

                done();
            });
    });

    it('should test koa with blocking and custom error handler', { plan: 6 }, (done) => {

        const iFace = getEcosystemMock();

        iFace[INTERFACES.TRANSPORT].sqreenBlocking = function (err, req, res) {

            expect(err.message).to.equal('Sqreen blocking Error');
            res.statusCode = 403;
            res.removeHeader('Content-Type');
            res.end('You have been blocked');
            return true;
        };

        iFace[INTERFACES.ENGINE].getNeededFieldSet = function () {

            return {
                has: () => true
            };
        };

        const propagated = [];
        iFace[INTERFACES.TRANSPORT].propagate = function (val, _, bool) {

            expect(bool).to.be.true();
            propagated.push(val);
        };

        Shimmer.wrap(Context, 'onerror', (onerror) => {

            return function shouldNotBeCalled(err) {

                if (err) {
                    expect('should not be called').to.equal(true);
                }
                else {
                    return onerror.apply(this, arguments);
                }
            };
        });

        const app = getApp(iFace);

        app.use(JsonError());

        app.use((ctx, next) => {

            throw new Error('Sqreen blocking Error');
        });

        SuperTest(app.callback())
            .get('/a/10?q=hello')
            .then((r) => {

                expect(r.statusCode).to.equal(403);
                expect(r.text).to.equal('You have been blocked');

                expect(propagated).to.have.length(1);
                expect(propagated[0]).to.equal({ 'server.request.query': { q: 'hello' } });

                done();
            });
    });

    it('should let legitimate errors go', { plan: 6 }, (done) => {

        const iFace = getEcosystemMock();

        iFace[INTERFACES.TRANSPORT].sqreenBlocking = function () {

            return false;
        };

        iFace[INTERFACES.ENGINE].getNeededFieldSet = function () {

            return {
                has: () => true
            };
        };

        const propagated = [];
        iFace[INTERFACES.TRANSPORT].propagate = function (val, _, bool) {

            expect(bool).to.be.true();
            propagated.push(val);
        };

        Shimmer.wrap(Context, 'onerror', (onerror) => {

            return function shouldBeCalled(err) {

                if (err) {
                    expect(err.message).to.equal('not Sqreen blocking Error');
                }

                return onerror.apply(this, arguments);
            };
        });

        const app = getApp(iFace);

        app.use((ctx, next) => {

            ctx.status = 200;
            return next();
        });

        app.use((ctx, next) => {

            const err = new Error('not Sqreen blocking Error');
            err.expose = true;
            throw err;
        });

        app.use((ctx, next) => {

            expect('should not be called').to.equal(true);
        });

        SuperTest(app.callback())
            .get('/?q=hello')
            .then((r) => {

                expect(r.statusCode).to.equal(500);
                expect(r.text).to.equal('not Sqreen blocking Error');

                expect(propagated).to.have.length(1);
                expect(propagated[0]).to.equal({ 'server.request.query': { q: 'hello' } });

                done();
            });
    });

    it('should let legitimate errors go with custom error handler', { plan: 5 }, (done) => {

        const iFace = getEcosystemMock();

        iFace[INTERFACES.TRANSPORT].sqreenBlocking = function () {

            return false;
        };

        iFace[INTERFACES.ENGINE].getNeededFieldSet = function () {

            return {
                has: () => true
            };
        };

        const propagated = [];
        iFace[INTERFACES.TRANSPORT].propagate = function (val, _, bool) {

            expect(bool).to.be.true();
            propagated.push(val);
        };

        Shimmer.wrap(Context, 'onerror', (onerror) => {

            return function shouldNotBeCalled(err) {

                if (err) {
                    expect('should not be called').to.equal(true);
                }
                else {
                    return onerror.apply(this, arguments);
                }
            };
        });

        const app = getApp(iFace);

        app.use(JsonError());

        app.use((ctx, next) => {

            ctx.status = 200;
            return next();
        });

        app.use((ctx, next) => {

            const err = new Error('not Sqreen blocking Error');
            err.expose = true;
            throw err;
        });

        app.use((ctx, next) => {

            expect('should not be called').to.equal(true);
        });

        SuperTest(app.callback())
            .get('/?q=hello')
            .then((r) => {

                expect(r.statusCode).to.equal(500);
                expect(r.body.message).to.equal('not Sqreen blocking Error');

                expect(propagated).to.have.length(1);
                expect(propagated[0]).to.equal({ 'server.request.query': { q: 'hello' } });

                done();
            });
    });
});
