/**
 * Copyright (c) 2016 - 2020 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();

const describe = lab.describe;
const beforeEach = lab.beforeEach;
const it = lab.it;
const expect = Code.expect;

const SuperTest = require('supertest');
const ExpressHook = require('../../../../lib/transport/web_frameworks/express_versions/express4');
const ExpressGlobalHook = require('../../../../lib/transport/web_frameworks/express');
const INTERFACES = require('../../../../lib/enums').INTERFACES;
const getEcosystemMock = require('../../../test_utils').getEcosystemMock;

const Express = require('express');
const BP = require('body-parser');
const CP = require('cookie-parser');
const Layer = require('express/lib/router/layer');

const unpatch = function (item) {

    if (typeof item.__unwrap === 'function') {
        item.__unwrap();
    }
};

const unpatchExpress = function () {

    unpatch(Express.Router.use);
    unpatch(Express.Router.route);
    unpatch(Express.Router.process_params);
    unpatch(Express.application.use);
    unpatch(Express.application.lazyrouter);
};

const printIfError = function (r) {

    if (r.statusCode !== 200) {
        console.log(r.text);
    }
};

describe('Express', () => {

    it('should cover dispatcher', { plan: 0 }, (done) => {

        ExpressGlobalHook({ identity: { version: '99.13.4' }, request: 'express', module: {} }, {});
        done();
    });
});

describe('Express 4', () => {

    beforeEach((done) => {

        unpatchExpress();
        done();
    });

    it('should test express', { plan: 9 }, (done) => {

        const iFace = getEcosystemMock();

        let request;
        let response;
        const session = {
            get(k) {

                if (k === 'req') {
                    return request;
                }
            },
            set(k, v) {

                if (k === 'req') {
                    request = v;
                }
                if (k === 'res') {
                    response = v;
                }
            },
            run(cb) {

                return cb();
            },
            bind(f) {

                return f;
            }
        };
        iFace[INTERFACES.TRANSPORT].getSession = function () {

            return session;
        };
        iFace[INTERFACES.TRANSPORT].getLegacySqreenMiddleware = function () {

            return function (req, res, next) {

                next();
            };
        };

        iFace[INTERFACES.ENGINE].getNeededFieldSet = function () {

            return {
                has: () => true
            };
        };

        const propagated = [];
        iFace[INTERFACES.TRANSPORT].propagate = function (val, _, bool) {

            expect(bool).to.be.true();
            propagated.push(val);
        };

        // This request thing does not work: TODO: add a relative path based fix
        ExpressGlobalHook({ identity: { version: '4.13.4' }, request: 'not-express', module: Express }, iFace);
        ExpressGlobalHook({ identity: { version: '4.13.4' }, request: 'express', module: Express }, iFace);
        ExpressGlobalHook({ identity: { version: '4.13.4' }, request: './layer', module: Layer }, iFace);

        const app = Express();

        app.use((req, res, next) => {

            req.__route = '';
            next();
        });

        app.get('/a/10', (req, res, next) => {

            next();
        });

        app.get('/a/:i', (req, res) => {

            expect(request === req).to.be.true();
            expect(response === res).to.be.true();
            expect(req.__route).to.equal('/a/:i');
            res.end('ok\n');
        });

        SuperTest(app)
            .get('/a/10?q[b]=hello')
            .then((r) => {

                printIfError(r);
                expect(r.statusCode).to.equal(200);

                expect(propagated).to.have.length(2);
                expect(propagated).to.include({ 'server.request.query': { q: { b: 'hello' } } });
                expect(propagated).to.include({ 'server.request.path_params': { i: '10' } });

                done();
            });
    });

    it('should test express with blocking', { plan: 5 }, (done) => {

        const iFace = getEcosystemMock();

        let request;
        // let response;
        const session = {
            get(k) {

                if (k === 'req') {
                    return request;
                }
            },
            set(k, v) {

                if (k === 'req') {
                    request = v;
                }
                if (k === 'res') {
                    // response = v;
                }
            },
            run(cb) {

                return cb();
            },
            bind(f) {

                return f;
            }
        };
        iFace[INTERFACES.TRANSPORT].getSession = function () {

            return session;
        };
        iFace[INTERFACES.TRANSPORT].getLegacySqreenMiddleware = function () {

            return function (req, res, next) {

                next();
            };
        };

        iFace[INTERFACES.TRANSPORT].sqreenBlocking = function (err, req, res) {

            expect(err.message).to.equal('Sqreen blocking Error');
            res.status(403);
            res.end('err\n');
            return true;
        };

        iFace[INTERFACES.ENGINE].getNeededFieldSet = function () {

            return {
                has: () => true
            };
        };

        const propagated = [];
        iFace[INTERFACES.TRANSPORT].propagate = function (val, _, bool) {

            expect(bool).to.be.true();
            propagated.push(val);
            throw new Error('Sqreen blocking Error');
        };

        // This request thing does not work: TODO: add a relative path based fix
        ExpressGlobalHook({ identity: { version: '4.13.4' }, request: 'not-express', module: Express }, iFace);
        ExpressGlobalHook({ identity: { version: '4.13.4' }, request: 'express', module: Express }, iFace);
        ExpressGlobalHook({ identity: { version: '4.13.4' }, request: './layer', module: Layer }, iFace);

        const app = Express();

        app.use((err, req, res, next) => {

            done(err);
        });

        SuperTest(app)
            .get('/a/10?q[b]=hello')
            .then((r) => {

                expect(r.statusCode).to.equal(403);

                expect(propagated).to.have.length(1);
                expect(propagated).to.include({ 'server.request.query': { q: { b: 'hello' } } });

                done();
            });
    });

    it('should let legitimate errors go', { plan: 4 }, (done) => {

        const iFace = getEcosystemMock();

        let request;
        // let response;
        const session = {
            get(k) {

                if (k === 'req') {
                    return request;
                }
            },
            set(k, v) {

                if (k === 'req') {
                    request = v;
                }
                if (k === 'res') {
                    // response = v;
                }
            },
            run(cb) {

                return cb();
            },
            bind(f) {

                return f;
            }
        };
        iFace[INTERFACES.TRANSPORT].getSession = function () {

            return session;
        };
        iFace[INTERFACES.TRANSPORT].getLegacySqreenMiddleware = function () {

            return function (req, res, next) {

                next();
            };
        };

        iFace[INTERFACES.TRANSPORT].sqreenBlocking = function () {

            return false;
        };

        iFace[INTERFACES.ENGINE].getNeededFieldSet = function () {

            return {
                has: () => true
            };
        };

        const propagated = [];
        iFace[INTERFACES.TRANSPORT].propagate = function (val, _, bool) {

            propagated.push(val);
        };

        // This request thing does not work: TODO: add a relative path based fix
        ExpressGlobalHook({ identity: { version: '4.13.4' }, request: 'not-express', module: Express }, iFace);
        ExpressGlobalHook({ identity: { version: '4.13.4' }, request: 'express', module: Express }, iFace);
        ExpressGlobalHook({ identity: { version: '4.13.4' }, request: './layer', module: Layer }, iFace);

        const app = Express();

        app.get(/hello/, () => {});

        app.get('/', () => {

            throw new Error('not Sqreen blocking Error');
        });


        app.use((err, req, res, next) => {

            res.status(500);
            expect(err.message).to.equal('not Sqreen blocking');
            res.end('err\n');
        });

        SuperTest(app)
            .get('/?q[b]=hello')
            .then((r) => {

                expect(r.statusCode).to.equal(500);

                expect(propagated).to.have.length(1);
                expect(propagated).to.include({ 'server.request.query': { q: { b: 'hello' } } });

                done();
            });
    });

    it('should test express without sending anything', { plan: 4 }, (done) => {

        const iFace = getEcosystemMock();

        let request;
        let response;
        const session = {
            get(k) {

                if (k === 'req') {
                    return request;
                }
            },
            set(k, v) {

                if (k === 'req') {
                    request = v;
                }
                if (k === 'res') {
                    response = v;
                }
            },
            run(cb) {

                return cb();
            },
            bind(f) {

                return f;
            }
        };
        iFace[INTERFACES.TRANSPORT].getSession = function () {

            return session;
        };
        iFace[INTERFACES.TRANSPORT].getLegacySqreenMiddleware = function () {

            return function (req, res, next) {

                next();
            };
        };

        iFace[INTERFACES.ENGINE].getNeededFieldSet = function () {

            return {
                has: () => false
            };
        };

        // This request thing does not work: TODO: add a relative path based fix
        ExpressHook({ identity: { version: '4.13.4' }, request: 'express', module: Express }, iFace);
        ExpressHook({ identity: { version: '4.13.4' }, request: './layer', module: Layer }, iFace);

        const app = Express();
        app.get('/a/:i', (req, res) => {

            expect(request === req).to.be.true();
            expect(response === res).to.be.true();
            expect(req.__route).to.equal('/a/:i');
            res.end('ok\n');
        });

        SuperTest(app)
            .get('/a/10?q[b]=hello')
            .then((r) => {

                printIfError(r);
                expect(r.statusCode).to.equal(200);

                done();
            });
    });

    it('should test express with diverse middlewares', { plan: 13 }, (done) => {

        const iFace = getEcosystemMock();

        let request;
        let response;
        const session = {
            get(k) {

                if (k === 'req') {
                    return request;
                }
            },
            set(k, v) {

                if (k === 'req') {
                    request = v;
                }
                if (k === 'res') {
                    response = v;
                }
            },
            run(cb) {

                return cb();
            },
            bind(f) {

                return f;
            }
        };
        iFace[INTERFACES.TRANSPORT].getSession = function () {

            return session;
        };
        iFace[INTERFACES.TRANSPORT].getLegacySqreenMiddleware = function () {

            return function (req, res, next) {

                next();
            };
        };

        iFace[INTERFACES.ENGINE].getNeededFieldSet = function () {

            return {
                has: () => true
            };
        };

        const propagated = [];
        iFace[INTERFACES.TRANSPORT].propagate = function (val, _, bool) {

            expect(bool).to.be.true();
            propagated.push(val);
        };

        // This request thing does not work: TODO: add a relative path based fix
        ExpressHook({ identity: { version: '4' }, request: 'express', module: Express }, iFace);
        ExpressHook({ identity: { version: '4' }, request: './layer', module: Layer }, iFace);

        const app = Express();
        app.use(BP.json());
        app.use(CP());

        app.get('/a/:i', (req, res) => {

            expect(request === req).to.be.true();
            expect(response === res).to.be.true();
            expect(req.__route).to.equal('/a/:i');
            res.end('ok\n');
        });

        SuperTest(app)
            .get('/a/10?q[b]=hello')
            .then((r) => {

                printIfError(r);
                expect(r.statusCode).to.equal(200);

                expect(propagated).to.have.length(4);
                expect(propagated).to.include({ 'server.request.body': {} });
                expect(propagated).to.include({ 'server.request.cookies': Object.create(null) });
                expect(propagated).to.include({ 'server.request.query': { q: { b: 'hello' } } });
                expect(propagated).to.include({ 'server.request.path_params': { i: '10' } });

                done();
            });
    });

    it('should test express with diverse middlewares on Router', { plan: 13 }, (done) => {

        const iFace = getEcosystemMock();

        let request;
        let response;
        const session = {
            get(k) {

                if (k === 'req') {
                    return request;
                }
            },
            set(k, v) {

                if (k === 'req') {
                    request = v;
                }
                if (k === 'res') {
                    response = v;
                }
            },
            run(cb) {

                return cb();
            },
            bind(f) {

                return f;
            }
        };
        iFace[INTERFACES.TRANSPORT].getSession = function () {

            return session;
        };
        iFace[INTERFACES.TRANSPORT].getLegacySqreenMiddleware = function () {

            return function (req, res, next) {

                next();
            };
        };

        iFace[INTERFACES.ENGINE].getNeededFieldSet = function () {

            return {
                has: () => true
            };
        };

        const propagated = [];
        iFace[INTERFACES.TRANSPORT].propagate = function (val, _, bool) {

            expect(bool).to.be.true();
            propagated.push(val);
        };

        // This request thing does not work: TODO: add a relative path based fix
        ExpressHook({ identity: { version: '4' }, request: 'express', module: Express }, iFace);
        ExpressHook({ identity: { version: '4' }, request: './layer', module: Layer }, iFace);

        const app = Express();
        const router = Express.Router();
        router.use(BP.json());
        router.use(CP());

        router.get('/a/:i', (req, res) => {

            expect(request === req).to.be.true();
            expect(response === res).to.be.true();
            expect(req.__route).to.equal('/a/:i');
            res.end('ok\n');
        });

        app.use(router);

        SuperTest(app)
            .get('/a/10?q[b]=hello')
            .then((r) => {

                printIfError(r);
                expect(r.statusCode).to.equal(200);

                expect(propagated).to.have.length(4);
                expect(propagated).to.include({ 'server.request.body': {} });
                expect(propagated).to.include({ 'server.request.cookies': Object.create(null) });
                expect(propagated).to.include({ 'server.request.query': { q: { b: 'hello' } } });
                expect(propagated).to.include({ 'server.request.path_params': { i: '10' } });

                done();
            });
    });

});
