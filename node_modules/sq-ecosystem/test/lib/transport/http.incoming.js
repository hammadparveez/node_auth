/**
 * Copyright (c) 2016 - 2020 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();

const describe = lab.describe;
const afterEach = lab.afterEach;
const it = lab.it;
const expect = Code.expect;

const Http = require('http');
const Fs = require('fs');

const FormData = require('form-data');

const HttpHook = require('../../../lib/transport/http.incoming');
const INTERFACES = require('../../../lib/enums').INTERFACES;
const HEADERS = require('../../../lib/enums').HEADERS;
const TestUtils = require('../../test_utils/index');

describe('Transport', () => {

    describe('http', () => {

        afterEach((done) => {

            delete Http.Server.prototype.addListener;
            delete Http.Server.prototype.on;
            if (Http.get.__unwrap) {
                Http.get.__unwrap();
            }
            if (Http.request.__unwrap) {
                Http.request.__unwrap();
            }
            done();
        });

        describe('isEmitter', () => {

            it('should cover isEmitter', { plan: 5 }, (done) => {

                expect(HttpHook.isEmitter()).to.be.false();
                expect(HttpHook.isEmitter({})).to.be.false();
                expect(HttpHook.isEmitter({ on: 1 })).to.be.false();
                expect(HttpHook.isEmitter({ on: 1, addListener: 1 })).to.be.false();
                expect(HttpHook.isEmitter({ on: 1, addListener: 1, emit: false })).to.be.false();
                done();

            });
        });

        describe('_cleanup', () => {

            it('should cover code in cleanup when no record is present', { plan: 1 }, (done) => {

                const iFace = TestUtils.getEcosystemMock();
                const req = {};
                const session = {
                    run() {

                        throw new Error('Should not be called');
                    }
                };

                iFace[INTERFACES.TRANSPORT].stopIncomingTransaction = function (_req, cb) {

                    expect(_req).to.shallow.equal(req);
                    cb();
                    done();
                };

                HttpHook._cleanup(iFace.getInterface(INTERFACES.TRANSPORT), req, null, null, null, null, null, session);
            });
        });

        it('should hook an http server', { plan: 8 }, (done) => {

            const iFace = TestUtils.getEcosystemMock();

            const toPatch = new Set(['end', 'request', 'request_second_hook']);
            iFace[INTERFACES.INSTRUMENTATION].strategies.patchFunction = function (hold, method) {

                expect(toPatch.has(method)).to.be.true();
                expect(hold[method]).to.exist();
                toPatch.delete(method);
            };
            iFace[INTERFACES.INSTRUMENTATION].registerHttpServerForReveal = function () {};
            iFace[INTERFACES.TRANSPORT].enableHTTP = function () {};
            iFace[INTERFACES.INSTRUMENTATION].strategies.patchEventListeners = function (holder, event) {

                expect(holder).to.equal(Http.Server.prototype);
                expect(event).to.equal('request');
            };
            HttpHook({ module: Http, identity: {} }, iFace);
            done();
        });

        it('should intercept the lifecycle of an HTTP request', { plan: 18 }, (done) => {

            const iFace = TestUtils.getEcosystemMock();

            const mockedSession = {
                run: (cb) => cb(),
                set: function (key, value) {

                    if (key === 'req') {
                        expect(value instanceof Http.IncomingMessage).to.be.true();
                    }
                    if (key === 'res') {
                        expect(value instanceof Http.ServerResponse).to.be.true();
                    }
                },
                bindEmitter: function () {}
            };
            const mockedBudget = { // TODO: must call
                startCount: function () {},
                stopCount: function () {}
            };

            iFace[INTERFACES.INSTRUMENTATION].strategies.patchFunction = function (hold, method) {};
            iFace[INTERFACES.INSTRUMENTATION].strategies.patchEventListeners = function (holder, event, hookFactory) {

                expect(event).to.equal('request');
                const addListener = holder.addListener;
                holder.addListener = function (evt, listener) {

                    if (evt === event) {
                        arguments[1] = hookFactory(this, listener);
                    }
                    return addListener.apply(this, arguments);
                };
                holder.on = holder.addListener;
                // TODO
            };
            const stopped = new WeakSet();
            iFace[INTERFACES.TRANSPORT].utils.getXFFOrRemoteAddress = function (req) {

                expect(req instanceof Http.IncomingMessage).to.be.true();
                return '127.0.0.1';
            };
            iFace[INTERFACES.TRANSPORT].utils.ensureProperIP = function (ip) {

                expect(ip).to.equal('127.0.0.1');
                return '127.0.0.1';
            };
            iFace[INTERFACES.TRANSPORT].ipAndPath.checkIPandPath = function (ipAddress, req, res) {

                expect(ipAddress).to.equal('127.0.0.1');
                return iFace[INTERFACES.TRANSPORT].ipAndPath.ACTIONS.NONE;
            };
            iFace[INTERFACES.ENGINE].getNeededFieldSet = function () {

                return new Set();
            };
            iFace[INTERFACES.TRANSPORT].startIncomingTransaction = function (reference, cb) {

                expect(reference instanceof Http.IncomingMessage).to.be.true();
                return cb(mockedSession, mockedBudget, mockedBudget);
            };
            iFace[INTERFACES.TRANSPORT].shouldPropagate = function (scope) {

                expect(scope).to.equal('server');
                return {
                    fields: [],
                    trigger: {}
                };
            };

            let port = '';
            iFace[INTERFACES.TRANSPORT].propagate = function (resolved, trigger) {

                expect(trigger).to.equal({});
                expect(resolved).to.equal({
                    'server.request.method': 'GET',
                    'server.request.client_ip': '127.0.0.1',
                    'server.request.headers.no_cookies': {
                        'connection': 'close',
                        'host': 'localhost:' + port
                    },
                    'server.request.tracing_identifier': '',
                    'server.request.transport': 'http',
                    'server.request.uri.raw': '/'
                });
                return function () {};
            };

            iFace[INTERFACES.TRANSPORT].stopIncomingTransaction = function (reference, cb) {

                if (stopped.has(reference)) {
                    return;
                }
                stopped.add(reference);
                expect(reference instanceof Http.IncomingMessage).to.be.true();
                return cb();
            };
            iFace[INTERFACES.INSTRUMENTATION].registerHttpServerForReveal = function () {};
            iFace[INTERFACES.TRANSPORT].enableHTTP = function () {};
            iFace[INTERFACES.TRANSPORT].stopHttpTransaction = function () {};
            iFace[INTERFACES.TRANSPORT].getHttpTrace = function (reference, ipAddress) {

                expect(reference instanceof Http.IncomingMessage).to.be.true();
                expect(ipAddress).to.equal('127.0.0.1');

                return {};
            };
            iFace[INTERFACES.TRACING].shouldTrace = function () {

                return null;
            };

            expect(Http.Server.prototype.hasOwnProperty('addListener')).to.be.false();
            HttpHook({ module: Http, identity: {} }, iFace);
            expect(Http.Server.prototype.hasOwnProperty('addListener')).to.be.true();

            const s = Http
                .createServer((req, res) => {

                    res.write('ok\n');
                    res.__sqreen_finisehd = true;
                    res.write('should not go through');
                    res.end();
                })
                .listen();

            port = s.address().port;
            Http.get({ port: s.address().port }, ( res) => {

                const chunks = [];
                res.on('data', (c) => chunks.push(c));
                res.on('end', () => {

                    const payload = Buffer.concat(chunks);
                    expect(payload.toString()).to.equal('ok\n');
                    s.close(() => {

                        done();
                    });
                });
            });
        });

        it('should intercept the lifecycle of an HTTP request and the response', { plan: 20 }, (done) => {

            const iFace = TestUtils.getEcosystemMock();

            const mockedSession = {
                run: (cb) => cb(),
                set: function (key, value) {

                    if (key === 'req') {
                        expect(value instanceof Http.IncomingMessage).to.be.true();
                    }
                    if (key === 'res') {
                        expect(value instanceof Http.ServerResponse).to.be.true();
                    }
                },
                bindEmitter: function () {}
            };
            const mockedBudget = { // TODO: must call
                startCount: function () {},
                stopCount: function () {}
            };

            iFace[INTERFACES.INSTRUMENTATION].strategies.patchFunction = function (hold, method) {};
            iFace[INTERFACES.INSTRUMENTATION].strategies.patchEventListeners = function (holder, event, hookFactory) {

                expect(event).to.equal('request');
                const addListener = holder.addListener;
                holder.addListener = function (evt, listener) {

                    if (evt === event) {
                        arguments[1] = hookFactory(this, listener);
                    }
                    return addListener.apply(this, arguments);
                };
                holder.on = holder.addListener;
                // TODO
            };
            const stopped = new WeakSet();
            iFace[INTERFACES.TRANSPORT].utils.getXFFOrRemoteAddress = function (req) {

                expect(req instanceof Http.IncomingMessage).to.be.true();
                return '127.0.0.1';
            };
            iFace[INTERFACES.TRANSPORT].utils.ensureProperIP = function (ip) {

                expect(ip).to.equal('127.0.0.1');
                return '127.0.0.1';
            };
            iFace[INTERFACES.TRANSPORT].ipAndPath.checkIPandPath = function (ipAddress, req, res) {

                expect(ipAddress).to.equal('127.0.0.1');
                return iFace[INTERFACES.TRANSPORT].ipAndPath.ACTIONS.NONE;
            };
            iFace[INTERFACES.ENGINE].getNeededFieldSet = function () {

                return new Set(['server.response.body.raw', 'server.response.status']);
            };
            iFace[INTERFACES.TRANSPORT].startIncomingTransaction = function (reference, cb) {

                expect(reference instanceof Http.IncomingMessage).to.be.true();
                return cb(mockedSession, mockedBudget, mockedBudget);
            };
            iFace[INTERFACES.TRANSPORT].shouldPropagate = function (scope) {

                expect(scope).to.equal('server');
                return {
                    fields: [],
                    trigger: {}
                };
            };

            let port = '';
            let ct = 0;
            iFace[INTERFACES.TRANSPORT].propagate = function (resolved, trigger) {

                if (ct === 0) {
                    expect(trigger).to.equal({});
                    expect(resolved).to.equal({
                        'server.request.method': 'GET',
                        'server.request.client_ip': '127.0.0.1',
                        'server.request.headers.no_cookies': {
                            'connection': 'close',
                            'host': 'localhost:' + port
                        },
                        'server.request.tracing_identifier': '',
                        'server.request.transport': 'http',
                        'server.request.uri.raw': '/'
                    });
                }

                if (ct === 1) {
                    expect(resolved['server.response.body.raw']).to.equal('sqreen'.repeat(1024).slice(0, 1024));
                }

                if (ct === 2) {
                    expect(resolved['server.response.status']).to.equal(200);
                }
                ++ct;
                return function () {};
            };

            iFace[INTERFACES.TRANSPORT].stopIncomingTransaction = function (reference, cb) {

                if (stopped.has(reference)) {
                    return;
                }
                stopped.add(reference);
                expect(reference instanceof Http.IncomingMessage).to.be.true();
                return cb();
            };
            iFace[INTERFACES.INSTRUMENTATION].registerHttpServerForReveal = function () {};
            iFace[INTERFACES.TRANSPORT].enableHTTP = function () {};
            iFace[INTERFACES.TRANSPORT].stopHttpTransaction = function () {};
            iFace[INTERFACES.TRANSPORT].getHttpTrace = function (reference, ipAddress) {

                expect(reference instanceof Http.IncomingMessage).to.be.true();
                expect(ipAddress).to.equal('127.0.0.1');

                return {};
            };
            iFace[INTERFACES.TRACING].shouldTrace = function () {

                return null;
            };

            expect(Http.Server.prototype.hasOwnProperty('addListener')).to.be.false();
            HttpHook({ module: Http, identity: {} }, iFace);
            expect(Http.Server.prototype.hasOwnProperty('addListener')).to.be.true();

            const s = Http
                .createServer((req, res) => {

                    for (let i = 0; i < 1024; ++i) {
                        if (i % 2 === 0) {
                            res.write('sqreen');
                        }
                        else {
                            res.write(Buffer.from('sqreen'));
                        }
                        try {
                            res.write(1);
                        }
                        catch (_) {}
                    }
                    res.end();
                })
                .listen();

            port = s.address().port;
            Http.get({ port: s.address().port }, ( res) => {

                const chunks = [];
                res.on('data', (c) => chunks.push(c));
                res.on('end', () => {

                    const payload = Buffer.concat(chunks);
                    expect(payload.toString()).to.equal('sqreen'.repeat(1024));
                    s.close(() => {

                        done();
                    });
                });
            });
        });

        it('should intercept the lifecycle of an HTTP request and the response', { plan: 20 }, (done) => {

            const iFace = TestUtils.getEcosystemMock();

            const mockedSession = {
                run: (cb) => cb(),
                set: function (key, value) {

                    if (key === 'req') {
                        expect(value instanceof Http.IncomingMessage).to.be.true();
                    }
                    if (key === 'res') {
                        expect(value instanceof Http.ServerResponse).to.be.true();
                    }
                },
                bindEmitter: function () {}
            };
            const mockedBudget = { // TODO: must call
                startCount: function () {},
                stopCount: function () {}
            };

            iFace[INTERFACES.INSTRUMENTATION].strategies.patchFunction = function (hold, method) {};
            iFace[INTERFACES.INSTRUMENTATION].strategies.patchEventListeners = function (holder, event, hookFactory) {

                expect(event).to.equal('request');
                const addListener = holder.addListener;
                holder.addListener = function (evt, listener) {

                    if (evt === event) {
                        arguments[1] = hookFactory(this, listener);
                    }
                    return addListener.apply(this, arguments);
                };
                holder.on = holder.addListener;
                // TODO
            };
            const stopped = new WeakSet();
            iFace[INTERFACES.TRANSPORT].utils.getXFFOrRemoteAddress = function (req) {

                expect(req instanceof Http.IncomingMessage).to.be.true();
                return '127.0.0.1';
            };
            iFace[INTERFACES.TRANSPORT].utils.ensureProperIP = function (ip) {

                expect(ip).to.equal('127.0.0.1');
                return '127.0.0.1';
            };
            iFace[INTERFACES.TRANSPORT].ipAndPath.checkIPandPath = function (ipAddress, req, res) {

                expect(ipAddress).to.equal('127.0.0.1');
                return iFace[INTERFACES.TRANSPORT].ipAndPath.ACTIONS.NONE;
            };
            iFace[INTERFACES.ENGINE].getNeededFieldSet = function () {

                return new Set(['server.response.body.raw', 'server.response.status']);
            };
            iFace[INTERFACES.TRANSPORT].startIncomingTransaction = function (reference, cb) {

                expect(reference instanceof Http.IncomingMessage).to.be.true();
                return cb(mockedSession, mockedBudget, mockedBudget);
            };
            iFace[INTERFACES.TRANSPORT].shouldPropagate = function (scope) {

                expect(scope).to.equal('server');
                return {
                    fields: [],
                    trigger: {}
                };
            };

            let port = '';
            let ct = 0;
            iFace[INTERFACES.TRANSPORT].propagate = function (resolved, trigger) {

                if (ct === 0) {
                    expect(trigger).to.equal({});
                    expect(resolved).to.equal({
                        'server.request.method': 'GET',
                        'server.request.client_ip': '127.0.0.1',
                        'server.request.headers.no_cookies': {
                            'connection': 'close',
                            'host': 'localhost:' + port
                        },
                        'server.request.tracing_identifier': '',
                        'server.request.transport': 'http',
                        'server.request.uri.raw': '/'
                    });
                }

                if (ct === 1) {
                    expect(resolved['server.response.body.raw']).to.equal('sqreen'.repeat(11));
                }

                if (ct === 2) {
                    expect(resolved['server.response.status']).to.equal(200);
                }
                ++ct;
                return function () {};
            };

            iFace[INTERFACES.TRANSPORT].stopIncomingTransaction = function (reference, cb) {

                if (stopped.has(reference)) {
                    return;
                }
                stopped.add(reference);
                expect(reference instanceof Http.IncomingMessage).to.be.true();
                return cb();
            };
            iFace[INTERFACES.INSTRUMENTATION].registerHttpServerForReveal = function () {};
            iFace[INTERFACES.TRANSPORT].enableHTTP = function () {};
            iFace[INTERFACES.TRANSPORT].stopHttpTransaction = function () {};
            iFace[INTERFACES.TRANSPORT].getHttpTrace = function (reference, ipAddress) {

                expect(reference instanceof Http.IncomingMessage).to.be.true();
                expect(ipAddress).to.equal('127.0.0.1');

                return {};
            };
            iFace[INTERFACES.TRACING].shouldTrace = function () {

                return null;
            };

            expect(Http.Server.prototype.hasOwnProperty('addListener')).to.be.false();
            HttpHook({ module: Http, identity: {} }, iFace);
            expect(Http.Server.prototype.hasOwnProperty('addListener')).to.be.true();

            const s = Http
                .createServer((req, res) => {

                    for (let i = 0; i < 10; ++i) {
                        if (i % 2 === 0) {
                            res.write('sqreen');
                        }
                        else {
                            res.write(Buffer.from('sqreen'));
                        }
                    }
                    res.end('sqreen');
                })
                .listen();

            port = s.address().port;
            Http.get({ port: s.address().port }, ( res) => {

                const chunks = [];
                res.on('data', (c) => chunks.push(c));
                res.on('end', () => {

                    const payload = Buffer.concat(chunks);
                    expect(payload.toString()).to.equal('sqreen'.repeat(11));
                    s.close(() => {

                        done();
                    });
                });
            });
        });

        it('should intercept the lifecycle of an HTTP request with body', { plan: 20 }, (done) => {

            const iFace = TestUtils.getEcosystemMock();

            const mockedSession = {
                run: (cb) => cb(),
                set: function (key, value) {

                    if (key === 'req') {
                        expect(value instanceof Http.IncomingMessage).to.be.true();
                    }
                    if (key === 'res') {
                        expect(value instanceof Http.ServerResponse).to.be.true();
                    }
                },
                bindEmitter: function () {}
            };
            const mockedBudget = { // TODO: must call
                startCount: function () {},
                stopCount: function () {}
            };

            iFace[INTERFACES.INSTRUMENTATION].strategies.patchFunction = function (hold, method) {};
            iFace[INTERFACES.INSTRUMENTATION].strategies.patchEventListeners = function (holder, event, hookFactory) {

                expect(event).to.equal('request');
                const addListener = holder.addListener;
                holder.addListener = function (evt, listener) {

                    if (evt === event) {
                        arguments[1] = hookFactory(this, listener);
                    }
                    return addListener.apply(this, arguments);
                };
                holder.on = holder.addListener;
                // TODO
            };
            const stopped = new WeakSet();
            iFace[INTERFACES.TRANSPORT].utils.getXFFOrRemoteAddress = function (req) {

                expect(req instanceof Http.IncomingMessage).to.be.true();
                return '127.0.0.1';
            };
            iFace[INTERFACES.TRANSPORT].utils.ensureProperIP = function (ip) {

                expect(ip).to.equal('127.0.0.1');
                return '127.0.0.1';
            };
            iFace[INTERFACES.TRANSPORT].ipAndPath.checkIPandPath = function (ipAddress, req, res) {

                expect(ipAddress).to.equal('127.0.0.1');
                return iFace[INTERFACES.TRANSPORT].ipAndPath.ACTIONS.NONE;
            };
            iFace[INTERFACES.ENGINE].getNeededFieldSet = function () {

                return new Set(['server.request.body.raw']);
            };
            iFace[INTERFACES.TRANSPORT].startIncomingTransaction = function (reference, cb) {

                expect(reference instanceof Http.IncomingMessage).to.be.true();
                return cb(mockedSession, mockedBudget, mockedBudget);
            };
            iFace[INTERFACES.TRANSPORT].shouldPropagate = function (scope) {

                expect(scope).to.equal('server');
                return {
                    fields: [],
                    trigger: {}
                };
            };

            let port = '';
            let call = 0;
            iFace[INTERFACES.TRANSPORT].propagate = function (resolved, trigger) {

                if (call === 0) {
                    expect(trigger).to.equal({});
                    expect(resolved).to.equal({
                        'server.request.method': 'POST',
                        'server.request.client_ip': '127.0.0.1',
                        'server.request.headers.no_cookies': {
                            'connection': 'close',
                            'transfer-encoding': 'chunked',
                            'host': 'localhost:' + port
                        },
                        'server.request.tracing_identifier': '',
                        'server.request.transport': 'http',
                        'server.request.uri.raw': '/'
                    });
                }

                if (call === 1) {

                    expect(resolved['server.request.body.raw']).to.equal(('first\n' + (new Array(500)).fill(0).map((_, i) => i).join('')).slice(0, 1024));
                }
                ++call;
                return function () {};
            };

            iFace[INTERFACES.TRANSPORT].stopIncomingTransaction = function (reference, cb) {

                if (stopped.has(reference)) {
                    return;
                }
                stopped.add(reference);
                expect(reference instanceof Http.IncomingMessage).to.be.true();
                return cb();
            };
            iFace[INTERFACES.INSTRUMENTATION].registerHttpServerForReveal = function () {};
            iFace[INTERFACES.TRANSPORT].enableHTTP = function () {};
            iFace[INTERFACES.TRANSPORT].stopHttpTransaction = function () {};
            iFace[INTERFACES.TRANSPORT].getHttpTrace = function (reference, ipAddress) {

                expect(reference instanceof Http.IncomingMessage).to.be.true();
                expect(ipAddress).to.equal('127.0.0.1');

                return {};
            };
            iFace[INTERFACES.TRACING].shouldTrace = function () {

                return null;
            };

            expect(Http.Server.prototype.hasOwnProperty('addListener')).to.be.false();
            HttpHook({ module: Http, identity: {} }, iFace);
            expect(Http.Server.prototype.hasOwnProperty('addListener')).to.be.true();

            const s = Http
                .createServer((req, res) => {

                    const bodyChunks = [];
                    process.nextTick(() => {

                        req.on('data', (chunk) => {

                            bodyChunks.push(chunk);
                        });

                        req.on('end', () => {

                            const body = Buffer.concat(bodyChunks).toString();
                            expect(body).to.equal('first\n' + (new Array(1024)).fill(0).map((_, i) => i).join(''));
                            // this makes sure the whole body is really passed to the legitimate listener!

                            res.write('ok\n');
                            res.__sqreen_finisehd = true;
                            res.write('should not go through');
                            res.end();
                        });
                    });
                })
                .listen();

            port = s.address().port;
            const req = Http.request({ port: s.address().port, method: 'POST', headers: { Cookie: 'hello' } }, ( res) => {

                const chunks = [];
                res.on('data', (c) => chunks.push(c));
                res.on('end', () => {

                    const payload = Buffer.concat(chunks);
                    expect(payload.toString()).to.equal('ok\n');
                    s.close(() => {

                        done();
                    });
                });
            });
            req.write('first\n');
            for (let i = 0; i < 1024; ++i) {
                req.write(i + '');
            }
            req.end();
        });

        it('should intercept the lifecycle of an HTTP request with files', { plan: 23 }, (done) => {

            const iFace = TestUtils.getEcosystemMock();

            const mockedSession = {
                run: (cb) => cb(),
                set: function (key, value) {

                    if (key === 'req') {
                        expect(value instanceof Http.IncomingMessage).to.be.true();
                    }
                    if (key === 'res') {
                        expect(value instanceof Http.ServerResponse).to.be.true();
                    }
                },
                bindEmitter: function () {}
            };
            const mockedBudget = { // TODO: must call
                startCount: function () {},
                stopCount: function () {}
            };

            iFace[INTERFACES.INSTRUMENTATION].strategies.patchFunction = function (hold, method) {};
            iFace[INTERFACES.INSTRUMENTATION].strategies.patchEventListeners = function (holder, event, hookFactory) {

                expect(event).to.equal('request');
                const addListener = holder.addListener;
                holder.addListener = function (evt, listener) {

                    if (evt === event) {
                        arguments[1] = hookFactory(this, listener);
                    }
                    return addListener.apply(this, arguments);
                };
                holder.on = holder.addListener;
                // TODO
            };
            const stopped = new WeakSet();
            iFace[INTERFACES.TRANSPORT].utils.getXFFOrRemoteAddress = function (req) {

                expect(req instanceof Http.IncomingMessage).to.be.true();
                return '127.0.0.1';
            };
            iFace[INTERFACES.TRANSPORT].utils.ensureProperIP = function (ip) {

                expect(ip).to.equal('127.0.0.1');
                return '127.0.0.1';
            };
            iFace[INTERFACES.TRANSPORT].ipAndPath.checkIPandPath = function (ipAddress, req, res) {

                expect(ipAddress).to.equal('127.0.0.1');
                return iFace[INTERFACES.TRANSPORT].ipAndPath.ACTIONS.NONE;
            };
            iFace[INTERFACES.ENGINE].getNeededFieldSet = function () {

                return new Set(['server.request.body.raw', 'server.request.body.files_field_names', 'server.request.body.filenames', 'server.request.body.combined_file_size']);
            };
            iFace[INTERFACES.TRANSPORT].startIncomingTransaction = function (reference, cb) {

                expect(reference instanceof Http.IncomingMessage).to.be.true();
                return cb(mockedSession, mockedBudget, mockedBudget);
            };
            iFace[INTERFACES.TRANSPORT].shouldPropagate = function (scope) {

                expect(scope).to.equal('server');
                return {
                    fields: [],
                    trigger: {}
                };
            };

            let port = '';
            let call = 0;
            iFace[INTERFACES.TRANSPORT].propagate = function (resolved, trigger) {

                if (call === 0) {
                    expect(trigger).to.equal({});
                    const ct = resolved['server.request.headers.no_cookies']['content-type'];
                    expect(ct.startsWith('multipart/form-data; ')).to.be.true();
                    delete resolved['server.request.headers.no_cookies']['content-type'];
                    expect(resolved).to.equal({
                        'server.request.method': 'POST',
                        'server.request.client_ip': '127.0.0.1',
                        'server.request.headers.no_cookies': {
                            'connection': 'close',
                            'transfer-encoding': 'chunked',
                            'host': 'localhost:' + port
                        },
                        'server.request.tracing_identifier': '',
                        'server.request.transport': 'http',
                        'server.request.uri.raw': '/'
                    });
                }

                if (call === 1) {

                    expect(resolved['server.request.body.raw'].length).to.equal(1024);
                }

                if (call === 2) {
                    expect(resolved['server.request.body.combined_file_size']).to.be.above(46216);
                    expect(resolved['server.request.body.filenames']).to.equal(['filenameField']);
                    expect(resolved['server.request.body.files_field_names']).to.equal(['fieldField']);
                }

                ++call;
                return function () {};
            };

            iFace[INTERFACES.TRANSPORT].stopIncomingTransaction = function (reference, cb) {

                if (stopped.has(reference)) {
                    return;
                }
                stopped.add(reference);
                expect(reference instanceof Http.IncomingMessage).to.be.true();
                return cb();
            };
            iFace[INTERFACES.INSTRUMENTATION].registerHttpServerForReveal = function () {};
            iFace[INTERFACES.TRANSPORT].enableHTTP = function () {};
            iFace[INTERFACES.TRANSPORT].stopHttpTransaction = function () {};
            iFace[INTERFACES.TRANSPORT].getHttpTrace = function (reference, ipAddress) {

                expect(reference instanceof Http.IncomingMessage).to.be.true();
                expect(ipAddress).to.equal('127.0.0.1');

                return {};
            };
            iFace[INTERFACES.TRACING].shouldTrace = function () {

                return null;
            };

            expect(Http.Server.prototype.hasOwnProperty('addListener')).to.be.false();
            HttpHook({ module: Http, identity: {} }, iFace);
            expect(Http.Server.prototype.hasOwnProperty('addListener')).to.be.true();

            const s = Http
                .createServer((req, res) => {

                    req.on('data', () => {});

                    req.on('end', () => {

                        res.write('ok\n');
                        res.__sqreen_finisehd = true;
                        res.write('should not go through');
                        res.end();
                    });
                })
                .listen();

            port = s.address().port;
            const form = new FormData();
            const req = Http.request({ port: s.address().port, method: 'POST', headers: form.getHeaders() }, ( res) => {

                const chunks = [];
                res.on('data', (c) => chunks.push(c));
                res.on('end', () => {

                    const payload = Buffer.concat(chunks);
                    expect(payload.toString()).to.equal('ok\n');
                    s.close(() => {

                        done();
                    });
                });
            });

            form.append('fieldField', Fs.createReadStream(__filename), { filename: 'filenameField' });
            form.pipe(req);
        });

        it('should intercept the lifecycle of an HTTP request with files', { plan: 21 }, (done) => {

            const iFace = TestUtils.getEcosystemMock();

            const mockedSession = {
                run: (cb) => cb(),
                set: function (key, value) {

                    if (key === 'req') {
                        expect(value instanceof Http.IncomingMessage).to.be.true();
                    }
                    if (key === 'res') {
                        expect(value instanceof Http.ServerResponse).to.be.true();
                    }
                },
                bindEmitter: function () {}
            };
            const mockedBudget = { // TODO: must call
                startCount: function () {},
                stopCount: function () {}
            };

            iFace[INTERFACES.INSTRUMENTATION].strategies.patchFunction = function (hold, method) {};
            iFace[INTERFACES.INSTRUMENTATION].strategies.patchEventListeners = function (holder, event, hookFactory) {

                expect(event).to.equal('request');
                const addListener = holder.addListener;
                holder.addListener = function (evt, listener) {

                    if (evt === event) {
                        arguments[1] = hookFactory(this, listener);
                    }
                    return addListener.apply(this, arguments);
                };
                holder.on = holder.addListener;
                // TODO
            };
            const stopped = new WeakSet();
            iFace[INTERFACES.TRANSPORT].utils.getXFFOrRemoteAddress = function (req) {

                expect(req instanceof Http.IncomingMessage).to.be.true();
                return '127.0.0.1';
            };
            iFace[INTERFACES.TRANSPORT].utils.ensureProperIP = function (ip) {

                expect(ip).to.equal('127.0.0.1');
                return '127.0.0.1';
            };
            iFace[INTERFACES.TRANSPORT].ipAndPath.checkIPandPath = function (ipAddress, req, res) {

                expect(ipAddress).to.equal('127.0.0.1');
                return iFace[INTERFACES.TRANSPORT].ipAndPath.ACTIONS.NONE;
            };
            iFace[INTERFACES.ENGINE].getNeededFieldSet = function () {

                return new Set(['server.request.body.raw', 'server.request.body.combined_file_size']);
            };
            iFace[INTERFACES.TRANSPORT].startIncomingTransaction = function (reference, cb) {

                expect(reference instanceof Http.IncomingMessage).to.be.true();
                return cb(mockedSession, mockedBudget, mockedBudget);
            };
            iFace[INTERFACES.TRANSPORT].shouldPropagate = function (scope) {

                expect(scope).to.equal('server');
                return {
                    fields: [],
                    trigger: {}
                };
            };

            let port = '';
            let call = 0;
            iFace[INTERFACES.TRANSPORT].propagate = function (resolved, trigger) {

                if (call === 0) {
                    expect(trigger).to.equal({});
                    const ct = resolved['server.request.headers.no_cookies']['content-type'];
                    expect(ct.startsWith('multipart/form-data; ')).to.be.true();
                    delete resolved['server.request.headers.no_cookies']['content-type'];
                    expect(resolved).to.equal({
                        'server.request.method': 'POST',
                        'server.request.client_ip': '127.0.0.1',
                        'server.request.headers.no_cookies': {
                            'connection': 'close',
                            'transfer-encoding': 'chunked',
                            'host': 'localhost:' + port
                        },
                        'server.request.tracing_identifier': '',
                        'server.request.transport': 'http',
                        'server.request.uri.raw': '/'
                    });
                }

                if (call === 1) {

                    expect(resolved['server.request.body.raw'].length).to.equal(1024);
                }

                if (call === 2) {
                    expect(resolved['server.request.body.combined_file_size']).to.be.above(46216);
                }

                ++call;
                return function () {};
            };

            iFace[INTERFACES.TRANSPORT].stopIncomingTransaction = function (reference, cb) {

                if (stopped.has(reference)) {
                    return;
                }
                stopped.add(reference);
                expect(reference instanceof Http.IncomingMessage).to.be.true();
                return cb();
            };
            iFace[INTERFACES.INSTRUMENTATION].registerHttpServerForReveal = function () {};
            iFace[INTERFACES.TRANSPORT].enableHTTP = function () {};
            iFace[INTERFACES.TRANSPORT].stopHttpTransaction = function () {};
            iFace[INTERFACES.TRANSPORT].getHttpTrace = function (reference, ipAddress) {

                expect(reference instanceof Http.IncomingMessage).to.be.true();
                expect(ipAddress).to.equal('127.0.0.1');

                return {};
            };
            iFace[INTERFACES.TRACING].shouldTrace = function () {

                return null;
            };

            expect(Http.Server.prototype.hasOwnProperty('addListener')).to.be.false();
            HttpHook({ module: Http, identity: {} }, iFace);
            expect(Http.Server.prototype.hasOwnProperty('addListener')).to.be.true();

            const s = Http
                .createServer((req, res) => {

                    req.on('data', () => {});
                    req.on('end', () => {

                        res.write('ok\n');
                        res.__sqreen_finisehd = true;
                        res.write('should not go through');
                        res.end();
                    });
                })
                .listen();

            port = s.address().port;
            const form = new FormData();
            const req = Http.request({ port: s.address().port, method: 'POST', headers: form.getHeaders() }, ( res) => {

                const chunks = [];
                res.on('data', (c) => chunks.push(c));
                res.on('end', () => {

                    const payload = Buffer.concat(chunks);
                    expect(payload.toString()).to.equal('ok\n');
                    s.close(() => {

                        done();
                    });
                });
            });

            form.append('fieldField', Fs.createReadStream(__filename), { filename: 'filenameField' });
            form.pipe(req);
        });

        it('should intercept the lifecycle of an HTTP request with files', { plan: 18 }, (done) => {

            const iFace = TestUtils.getEcosystemMock();

            const mockedSession = {
                run: (cb) => cb(),
                set: function (key, value) {

                    if (key === 'req') {
                        expect(value instanceof Http.IncomingMessage).to.be.true();
                    }
                    if (key === 'res') {
                        expect(value instanceof Http.ServerResponse).to.be.true();
                    }
                },
                bindEmitter: function () {}
            };
            const mockedBudget = { // TODO: must call
                startCount: function () {},
                stopCount: function () {}
            };

            iFace[INTERFACES.INSTRUMENTATION].strategies.patchFunction = function (hold, method) {};
            iFace[INTERFACES.INSTRUMENTATION].strategies.patchEventListeners = function (holder, event, hookFactory) {

                expect(event).to.equal('request');
                const addListener = holder.addListener;
                holder.addListener = function (evt, listener) {

                    if (evt === event) {
                        arguments[1] = hookFactory(this, listener);
                    }
                    return addListener.apply(this, arguments);
                };
                holder.on = holder.addListener;
                // TODO
            };
            const stopped = new WeakSet();
            iFace[INTERFACES.TRANSPORT].utils.getXFFOrRemoteAddress = function (req) {

                expect(req instanceof Http.IncomingMessage).to.be.true();
                return '127.0.0.1';
            };
            iFace[INTERFACES.TRANSPORT].utils.ensureProperIP = function (ip) {

                expect(ip).to.equal('127.0.0.1');
                return '127.0.0.1';
            };
            iFace[INTERFACES.TRANSPORT].ipAndPath.checkIPandPath = function (ipAddress, req, res) {

                expect(ipAddress).to.equal('127.0.0.1');
                return iFace[INTERFACES.TRANSPORT].ipAndPath.ACTIONS.NONE;
            };
            iFace[INTERFACES.ENGINE].getNeededFieldSet = function () {

                return new Set(['server.request.body.raw', 'server.request.body.combined_file_size']);
            };
            iFace[INTERFACES.TRANSPORT].startIncomingTransaction = function (reference, cb) {

                expect(reference instanceof Http.IncomingMessage).to.be.true();
                return cb(mockedSession, mockedBudget, mockedBudget);
            };
            iFace[INTERFACES.TRANSPORT].shouldPropagate = function (scope) {

                expect(scope).to.equal('server');
                return {
                    fields: [],
                    trigger: {}
                };
            };

            let call = 0;
            iFace[INTERFACES.TRANSPORT].propagate = function (resolved, trigger) {

                if (call === 0) {
                    expect(trigger).to.equal({});
                }

                if (call === 1) {

                    expect(resolved['server.request.body.raw'].length).to.equal(1024);
                }

                if (call === 2) {
                    done(new Error('should not have been called'));
                }

                ++call;
                return function () {};
            };

            iFace[INTERFACES.TRANSPORT].stopIncomingTransaction = function (reference, cb) {

                if (stopped.has(reference)) {
                    return;
                }
                stopped.add(reference);
                expect(reference instanceof Http.IncomingMessage).to.be.true();
                return cb();
            };
            iFace[INTERFACES.INSTRUMENTATION].registerHttpServerForReveal = function () {};
            iFace[INTERFACES.TRANSPORT].enableHTTP = function () {};
            iFace[INTERFACES.TRANSPORT].stopHttpTransaction = function () {};
            iFace[INTERFACES.TRANSPORT].getHttpTrace = function (reference, ipAddress) {

                expect(reference instanceof Http.IncomingMessage).to.be.true();
                expect(ipAddress).to.equal('127.0.0.1');

                return {};
            };
            iFace[INTERFACES.TRACING].shouldTrace = function () {

                return null;
            };

            expect(Http.Server.prototype.hasOwnProperty('addListener')).to.be.false();
            HttpHook({ module: Http, identity: {} }, iFace);
            expect(Http.Server.prototype.hasOwnProperty('addListener')).to.be.true();

            const s = Http
                .createServer((req, res) => {

                    req.on('data', () => {});
                    req.on('end', () => {

                        res.write('ok\n');
                        res.__sqreen_finisehd = true;
                        res.write('should not go through');
                        res.end();
                    });
                })
                .listen();

            const form = new FormData();
            const req = Http.request({ port: s.address().port, method: 'POST', headers: {} }, ( res) => {

                const chunks = [];
                res.on('data', (c) => chunks.push(c));
                res.on('end', () => {

                    const payload = Buffer.concat(chunks);
                    expect(payload.toString()).to.equal('ok\n');
                    s.close(() => {

                        done();
                    });
                });
            });

            form.append('fieldField', Fs.createReadStream(__filename), { filename: 'filenameField' });
            form.pipe(req);
        });

        it('should intercept the lifecycle of an HTTP request with files', { plan: 22 }, (done) => {

            const iFace = TestUtils.getEcosystemMock();

            const mockedSession = {
                run: (cb) => cb(),
                set: function (key, value) {

                    if (key === 'req') {
                        expect(value instanceof Http.IncomingMessage).to.be.true();
                    }
                    if (key === 'res') {
                        expect(value instanceof Http.ServerResponse).to.be.true();
                    }
                },
                bindEmitter: function () {}
            };
            const mockedBudget = { // TODO: must call
                startCount: function () {},
                stopCount: function () {}
            };

            iFace[INTERFACES.INSTRUMENTATION].strategies.patchFunction = function (hold, method) {};
            iFace[INTERFACES.INSTRUMENTATION].strategies.patchEventListeners = function (holder, event, hookFactory) {

                expect(event).to.equal('request');
                const addListener = holder.addListener;
                holder.addListener = function (evt, listener) {

                    if (evt === event) {
                        arguments[1] = hookFactory(this, listener);
                    }
                    return addListener.apply(this, arguments);
                };
                holder.on = holder.addListener;
                // TODO
            };
            const stopped = new WeakSet();
            iFace[INTERFACES.TRANSPORT].utils.getXFFOrRemoteAddress = function (req) {

                expect(req instanceof Http.IncomingMessage).to.be.true();
                return '127.0.0.1';
            };
            iFace[INTERFACES.TRANSPORT].utils.ensureProperIP = function (ip) {

                expect(ip).to.equal('127.0.0.1');
                return '127.0.0.1';
            };
            iFace[INTERFACES.TRANSPORT].ipAndPath.checkIPandPath = function (ipAddress, req, res) {

                expect(ipAddress).to.equal('127.0.0.1');
                return iFace[INTERFACES.TRANSPORT].ipAndPath.ACTIONS.NONE;
            };
            iFace[INTERFACES.ENGINE].getNeededFieldSet = function () {

                return new Set(['server.request.body.raw', 'server.request.body.files_field_names', 'server.request.body.filenames']);
            };
            iFace[INTERFACES.TRANSPORT].startIncomingTransaction = function (reference, cb) {

                expect(reference instanceof Http.IncomingMessage).to.be.true();
                return cb(mockedSession, mockedBudget, mockedBudget);
            };
            iFace[INTERFACES.TRANSPORT].shouldPropagate = function (scope) {

                expect(scope).to.equal('server');
                return {
                    fields: [],
                    trigger: {}
                };
            };

            let port = '';
            let call = 0;
            iFace[INTERFACES.TRANSPORT].propagate = function (resolved, trigger) {

                if (call === 0) {
                    expect(trigger).to.equal({});
                    const ct = resolved['server.request.headers.no_cookies']['content-type'];
                    expect(ct.startsWith('multipart/form-data; ')).to.be.true();
                    delete resolved['server.request.headers.no_cookies']['content-type'];
                    expect(resolved).to.equal({
                        'server.request.method': 'POST',
                        'server.request.client_ip': '127.0.0.1',
                        'server.request.headers.no_cookies': {
                            'connection': 'close',
                            'transfer-encoding': 'chunked',
                            'host': 'localhost:' + port
                        },
                        'server.request.tracing_identifier': '',
                        'server.request.transport': 'http',
                        'server.request.uri.raw': '/'
                    });
                }

                if (call === 1) {

                    expect(resolved['server.request.body.raw'].length).to.equal(1024);
                }

                if (call === 2) {
                    expect(resolved['server.request.body.filenames']).to.equal(['filenameField']);
                    expect(resolved['server.request.body.files_field_names']).to.equal(['fieldField']);
                }

                ++call;
                return function () {};
            };

            iFace[INTERFACES.TRANSPORT].stopIncomingTransaction = function (reference, cb) {

                if (stopped.has(reference)) {
                    return;
                }
                stopped.add(reference);
                expect(reference instanceof Http.IncomingMessage).to.be.true();
                return cb();
            };
            iFace[INTERFACES.INSTRUMENTATION].registerHttpServerForReveal = function () {};

            iFace[INTERFACES.TRANSPORT].enableHTTP = function () {};
            iFace[INTERFACES.TRANSPORT].stopHttpTransaction = function () {};
            iFace[INTERFACES.TRANSPORT].getHttpTrace = function (reference, ipAddress) {

                expect(reference instanceof Http.IncomingMessage).to.be.true();
                expect(ipAddress).to.equal('127.0.0.1');

                return {};
            };
            iFace[INTERFACES.TRACING].shouldTrace = function () {

                return null;
            };

            expect(Http.Server.prototype.hasOwnProperty('addListener')).to.be.false();
            HttpHook({ module: Http, identity: {} }, iFace);
            expect(Http.Server.prototype.hasOwnProperty('addListener')).to.be.true();

            const s = Http
                .createServer((req, res) => {

                    req.on('data', () => {});
                    req.on('end', () => {

                        res.write('ok\n');
                        res.__sqreen_finisehd = true;
                        res.write('should not go through');
                        res.end();
                    });
                })
                .listen();

            port = s.address().port;
            const form = new FormData();
            const req = Http.request({ port: s.address().port, method: 'POST', headers: form.getHeaders() }, ( res) => {

                const chunks = [];
                res.on('data', (c) => chunks.push(c));
                res.on('end', () => {

                    const payload = Buffer.concat(chunks);
                    expect(payload.toString()).to.equal('ok\n');
                    s.close(() => {

                        done();
                    });
                });
            });

            form.append('fieldField', Fs.createReadStream(__filename), { filename: 'filenameField' });
            form.pipe(req);
        });

        it('should intercept the lifecycle of an HTTP request but callback-block it', { plan: 18 }, (done) => {

            const iFace = TestUtils.getEcosystemMock();

            const mockedSession = {
                run: (cb) => cb(),
                set: function (key, value) {

                    if (key === 'req') {
                        expect(value instanceof Http.IncomingMessage).to.be.true();
                    }
                    if (key === 'res') {
                        expect(value instanceof Http.ServerResponse).to.be.true();
                    }
                },
                bindEmitter: function () {}
            };
            const mockedBudget = { // TODO: must call
                startCount: function () {},
                stopCount: function () {}
            };

            iFace[INTERFACES.INSTRUMENTATION].strategies.patchFunction = function (hold, method) {

                if (method === 'request') {
                    hold[method] = function (ip, req, res) {

                        expect(ip).to.equal('127.0.0.1');
                        res.end('blocked\n');
                        return false;
                    };
                }
            };
            iFace[INTERFACES.INSTRUMENTATION].strategies.patchEventListeners = function (holder, event, hookFactory) {

                expect(event).to.equal('request');
                const addListener = holder.addListener;
                holder.addListener = function (evt, listener) {

                    if (evt === event) {
                        arguments[1] = hookFactory(this, listener);
                    }
                    return addListener.apply(this, arguments);
                };
                holder.on = holder.addListener;
                // TODO
            };
            const stopped = new WeakSet();
            iFace[INTERFACES.TRANSPORT].utils.getXFFOrRemoteAddress = function (req) {

                expect(req instanceof Http.IncomingMessage).to.be.true();
                return '127.0.0.1';
            };
            iFace[INTERFACES.TRANSPORT].utils.ensureProperIP = function (ip) {

                expect(ip).to.equal('127.0.0.1');
                return '127.0.0.1';
            };
            iFace[INTERFACES.TRANSPORT].ipAndPath.checkIPandPath = function (ipAddress, req, res) {

                expect(ipAddress).to.equal('127.0.0.1');
                return iFace[INTERFACES.TRANSPORT].ipAndPath.ACTIONS.NONE;
            };
            iFace[INTERFACES.ENGINE].getNeededFieldSet = function () {

                return new Set();
            };
            iFace[INTERFACES.INSTRUMENTATION].registerHttpServerForReveal = function () {};

            iFace[INTERFACES.TRANSPORT].startIncomingTransaction = function (reference, cb) {

                expect(reference instanceof Http.IncomingMessage).to.be.true();
                return cb(mockedSession, mockedBudget, mockedBudget);
            };
            iFace[INTERFACES.TRANSPORT].shouldPropagate = function (scope) {

                expect(scope).to.equal('server');
                return {
                    fields: ['transport'],
                    trigger: {}
                };
            };
            let port = '';
            iFace[INTERFACES.TRANSPORT].propagate = function (resolved) {

                expect(resolved).to.equal({
                    'server.request.method': 'GET',
                    'server.request.client_ip': '127.0.0.1',
                    'server.request.headers.no_cookies': {
                        'connection': 'close',
                        'host': 'localhost:' + port
                    },
                    'server.request.tracing_identifier': '',
                    'server.request.transport': 'http',
                    'server.request.uri.raw': '/'
                });
                return function () {};
            };
            iFace[INTERFACES.TRANSPORT].stopIncomingTransaction = function (reference, cb) {

                if (stopped.has(reference)) {
                    return;
                }
                stopped.add(reference);
                expect(reference instanceof Http.IncomingMessage).to.be.true();
                return cb();
            };
            iFace[INTERFACES.TRANSPORT].enableHTTP = function () {};
            iFace[INTERFACES.TRANSPORT].stopHttpTransaction = function () {};
            iFace[INTERFACES.TRANSPORT].getHttpTrace = function (reference, ipAddress) {

                expect(reference instanceof Http.IncomingMessage).to.be.true();
                expect(ipAddress).to.equal('127.0.0.1');

                return {};
            };
            iFace[INTERFACES.TRACING].shouldTrace = function () {

                return null;
            };
            expect(Http.Server.prototype.hasOwnProperty('addListener')).to.be.false();
            HttpHook({ module: Http, identity: {} }, iFace);
            expect(Http.Server.prototype.hasOwnProperty('addListener')).to.be.true();

            const s = Http
                .createServer((req, res) => {

                    res.end('ok\n');
                })
                .listen();

            port = s.address().port;
            Http.get({ port: s.address().port }, ( res) => {

                const chunks = [];
                res.on('data', (c) => chunks.push(c));
                res.on('end', () => {

                    const payload = Buffer.concat(chunks);
                    expect(payload.toString()).to.equal('blocked\n');
                    s.close(() => {

                        done();
                    });
                });
            });
        });

        it('should intercept the lifecycle of an HTTP request but callback-block it', { plan: 19 }, (done) => {

            const iFace = TestUtils.getEcosystemMock();

            const mockedSession = {
                run: (cb) => cb(),
                set: function (key, value) {

                    if (key === 'req') {
                        expect(value instanceof Http.IncomingMessage).to.be.true();
                    }
                    if (key === 'res') {
                        expect(value instanceof Http.ServerResponse).to.be.true();
                    }
                },
                bindEmitter: function () {}
            };
            const mockedBudget = { // TODO: must call
                startCount: function () {},
                stopCount: function () {}
            };

            iFace[INTERFACES.INSTRUMENTATION].strategies.patchFunction = function (hold, method) {

                if (method === 'request') {
                    hold[method] = function (ip, req, res) {

                        expect(ip).to.equal('127.0.0.1');
                        res.end('blocked\n');
                        return false;
                    };
                }
            };
            iFace[INTERFACES.INSTRUMENTATION].strategies.patchEventListeners = function (holder, event, hookFactory) {

                expect(event).to.equal('request');
                const addListener = holder.addListener;
                holder.addListener = function (evt, listener) {

                    if (evt === event) {
                        arguments[1] = hookFactory(this, listener);
                    }
                    return addListener.apply(this, arguments);
                };
                holder.on = holder.addListener;
                // TODO
            };
            const stopped = new WeakSet();
            iFace[INTERFACES.TRANSPORT].utils.getXFFOrRemoteAddress = function (req) {

                expect(req instanceof Http.IncomingMessage).to.be.true();
                return '127.0.0.1';
            };
            iFace[INTERFACES.TRANSPORT].utils.ensureProperIP = function (ip) {

                expect(ip).to.equal('127.0.0.1');
                return '127.0.0.1';
            };
            iFace[INTERFACES.TRANSPORT].ipAndPath.checkIPandPath = function (ipAddress, req, res) {

                expect(ipAddress).to.equal('127.0.0.1');
                return iFace[INTERFACES.TRANSPORT].ipAndPath.ACTIONS.NONE;
            };
            iFace[INTERFACES.INSTRUMENTATION].registerHttpServerForReveal = function () {};

            iFace[INTERFACES.ENGINE].getNeededFieldSet = function () {

                return new Set();
            };
            iFace[INTERFACES.TRANSPORT].startIncomingTransaction = function (reference, cb) {

                expect(reference instanceof Http.IncomingMessage).to.be.true();
                return cb(mockedSession, mockedBudget, mockedBudget);
            };

            iFace[INTERFACES.TRACING].getTracingIdentifier = function () {

                return 'foo';
            };

            iFace[INTERFACES.TRANSPORT].shouldPropagate = function (scope) {

                expect(scope).to.equal('server');
                return {
                    fields: ['transport', 'tracing_identifier'],
                    trigger: {}
                };
            };
            iFace[INTERFACES.TRANSPORT].propagate = function (resolved) {

                expect(resolved['server.request.transport']).to.equal('http');
                expect(resolved['server.request.tracing_identifier']).to.equal('track_id');
                return function () {};
            };
            iFace[INTERFACES.TRANSPORT].stopIncomingTransaction = function (reference, cb) {

                if (stopped.has(reference)) {
                    return;
                }
                stopped.add(reference);
                expect(reference instanceof Http.IncomingMessage).to.be.true();
                return cb();
            };
            iFace[INTERFACES.TRANSPORT].enableHTTP = function () {};
            iFace[INTERFACES.TRANSPORT].stopHttpTransaction = function () {};
            iFace[INTERFACES.TRANSPORT].getHttpTrace = function (reference, ipAddress) {

                expect(reference instanceof Http.IncomingMessage).to.be.true();
                expect(ipAddress).to.equal('127.0.0.1');

                return {};
            };
            iFace[INTERFACES.TRACING].shouldTrace = function () {

                return null;
            };
            expect(Http.Server.prototype.hasOwnProperty('addListener')).to.be.false();
            HttpHook({ module: Http, identity: { name: 'http' } }, iFace);
            expect(Http.Server.prototype.hasOwnProperty('addListener')).to.be.true();

            const s = Http
                .createServer((req, res) => {

                    res.end('ok\n');
                })
                .listen();

            Http.get({ port: s.address().port, headers: { [HEADERS.X_SQREEN_TRACKING]: 'track_id' } }, ( res) => {

                const chunks = [];
                res.on('data', (c) => chunks.push(c));
                res.on('end', () => {

                    const payload = Buffer.concat(chunks);
                    expect(payload.toString()).to.equal('blocked\n');
                    s.close(() => {

                        done();
                    });
                });
            });
        });

        it('should intercept the lifecycle of an HTTP request but callback-block it without ti', { plan: 19 }, (done) => {

            const iFace = TestUtils.getEcosystemMock();

            const mockedSession = {
                run: (cb) => cb(),
                set: function (key, value) {

                    if (key === 'req') {
                        expect(value instanceof Http.IncomingMessage).to.be.true();
                    }
                    if (key === 'res') {
                        expect(value instanceof Http.ServerResponse).to.be.true();
                    }
                },
                bindEmitter: function () {}
            };
            const mockedBudget = { // TODO: must call
                startCount: function () {},
                stopCount: function () {}
            };

            iFace[INTERFACES.INSTRUMENTATION].strategies.patchFunction = function (hold, method) {

                if (method === 'request') {
                    hold[method] = function (ip, req, res) {

                        expect(ip).to.equal('127.0.0.1');
                        res.end('blocked\n');
                        return false;
                    };
                }
            };
            iFace[INTERFACES.INSTRUMENTATION].strategies.patchEventListeners = function (holder, event, hookFactory) {

                expect(event).to.equal('request');
                const addListener = holder.addListener;
                holder.addListener = function (evt, listener) {

                    if (evt === event) {
                        arguments[1] = hookFactory(this, listener);
                    }
                    return addListener.apply(this, arguments);
                };
                holder.on = holder.addListener;
                // TODO
            };
            const stopped = new WeakSet();
            iFace[INTERFACES.TRANSPORT].utils.getXFFOrRemoteAddress = function (req) {

                expect(req instanceof Http.IncomingMessage).to.be.true();
                return '127.0.0.1';
            };
            iFace[INTERFACES.TRANSPORT].utils.ensureProperIP = function (ip) {

                expect(ip).to.equal('127.0.0.1');
                return '127.0.0.1';
            };
            iFace[INTERFACES.ENGINE].getNeededFieldSet = function () {

                return new Set();
            };
            iFace[INTERFACES.TRANSPORT].ipAndPath.checkIPandPath = function (ipAddress, req, res) {

                expect(ipAddress).to.equal('127.0.0.1');
                return iFace[INTERFACES.TRANSPORT].ipAndPath.ACTIONS.NONE;
            };
            iFace[INTERFACES.INSTRUMENTATION].registerHttpServerForReveal = function () {};

            iFace[INTERFACES.TRANSPORT].startIncomingTransaction = function (reference, cb) {

                expect(reference instanceof Http.IncomingMessage).to.be.true();
                return cb(mockedSession, mockedBudget, mockedBudget);
            };

            iFace[INTERFACES.TRACING].getTracingIdentifier = function () {

                return 'foo';
            };

            iFace[INTERFACES.TRANSPORT].shouldPropagate = function (scope) {

                expect(scope).to.equal('server');
                return {
                    fields: ['transport', 'tracing_identifier'],
                    trigger: {}
                };
            };
            iFace[INTERFACES.TRANSPORT].enableHTTP = function () {};
            iFace[INTERFACES.TRANSPORT].propagate = function (resolved) {

                expect(resolved['server.request.transport']).to.equal('http');
                expect(resolved['server.request.tracing_identifier']).to.equal('');
                return function () {};
            };
            iFace[INTERFACES.TRANSPORT].stopIncomingTransaction = function (reference, cb) {

                if (stopped.has(reference)) {
                    return;
                }
                stopped.add(reference);
                expect(reference instanceof Http.IncomingMessage).to.be.true();
                return cb();
            };
            iFace[INTERFACES.TRANSPORT].stopHttpTransaction = function () {};
            iFace[INTERFACES.TRANSPORT].getHttpTrace = function (reference, ipAddress) {

                expect(reference instanceof Http.IncomingMessage).to.be.true();
                expect(ipAddress).to.equal('127.0.0.1');

                return {};
            };
            iFace[INTERFACES.TRACING].shouldTrace = function () {

                return null;
            };
            expect(Http.Server.prototype.hasOwnProperty('addListener')).to.be.false();
            HttpHook({ module: Http, identity: { name: 'http' } }, iFace);
            expect(Http.Server.prototype.hasOwnProperty('addListener')).to.be.true();

            const s = Http
                .createServer((req, res) => {

                    res.end('ok\n');
                })
                .listen();

            Http.get({ port: s.address().port }, ( res) => {

                const chunks = [];
                res.on('data', (c) => chunks.push(c));
                res.on('end', () => {

                    const payload = Buffer.concat(chunks);
                    expect(payload.toString()).to.equal('blocked\n');
                    s.close(() => {

                        done();
                    });
                });
            });
        });

        it('should intercept the lifecycle of a whitelisted HTTP request', { plan: 16 }, (done) => {

            const iFace = TestUtils.getEcosystemMock();

            const mockedSession = {
                run: (cb) => cb(),
                set: function (key, value) {

                    if (key === 'req') {
                        expect(value instanceof Http.IncomingMessage).to.be.true();
                    }
                    if (key === 'res') {
                        expect(value instanceof Http.ServerResponse).to.be.true();
                    }
                },
                bindEmitter: function () {}
            };
            const mockedBudget = { // TODO: must call
                startCount: function () {},
                stopCount: function () {}
            };

            iFace[INTERFACES.INSTRUMENTATION].strategies.patchFunction = function (hold, method) {};
            iFace[INTERFACES.INSTRUMENTATION].strategies.patchEventListeners = function (holder, event, hookFactory) {

                expect(event).to.equal('request');
                const addListener = holder.addListener;
                holder.addListener = function (evt, listener) {

                    if (evt === event) {
                        arguments[1] = hookFactory(this, listener);
                    }
                    return addListener.apply(this, arguments);
                };
                holder.on = holder.addListener;
                // TODO
            };
            iFace[INTERFACES.TRANSPORT].propagate = function () {

                return function () {};
            };
            const stopped = new WeakSet();
            iFace[INTERFACES.TRANSPORT].utils.getXFFOrRemoteAddress = function (req) {

                expect(req instanceof Http.IncomingMessage).to.be.true();
                return '127.0.0.1';
            };
            iFace[INTERFACES.TRANSPORT].utils.ensureProperIP = function (ip) {

                expect(ip).to.equal('127.0.0.1');
                return '127.0.0.1';
            };
            iFace[INTERFACES.TRANSPORT].shouldPropagate = function (scope) {

                expect(scope).to.equal('server');
                return {
                    fields: [],
                    trigger: {}
                };
            };
            iFace[INTERFACES.ENGINE].getNeededFieldSet = function () {

                return new Set();
            };
            iFace[INTERFACES.TRANSPORT].ipAndPath.checkIPandPath = function (ipAddress, req, res) {

                req._sqreen_ip_whitelist = true;
                expect(ipAddress).to.equal('127.0.0.1');
                return iFace[INTERFACES.TRANSPORT].ipAndPath.ACTIONS.NONE;
            };
            iFace[INTERFACES.TRANSPORT].startIncomingTransaction = function (reference, cb) {

                expect(reference instanceof Http.IncomingMessage).to.be.true();
                return cb(mockedSession, mockedBudget, mockedBudget);
            };
            iFace[INTERFACES.TRANSPORT].stopIncomingTransaction = function (reference, cb) {

                if (stopped.has(reference)) {
                    return;
                }
                stopped.add(reference);
                expect(reference instanceof Http.IncomingMessage).to.be.true();
                return cb();
            };
            iFace[INTERFACES.INSTRUMENTATION].registerHttpServerForReveal = function () {};

            iFace[INTERFACES.TRANSPORT].stopHttpTransaction = function () {};
            iFace[INTERFACES.TRANSPORT].enableHTTP = function () {};
            iFace[INTERFACES.TRANSPORT].getHttpTrace = function (reference, ipAddress) {

                expect(reference instanceof Http.IncomingMessage).to.be.true();
                expect(ipAddress).to.equal('127.0.0.1');

                return {};
            };
            iFace[INTERFACES.TRACING].shouldTrace = function () {

                return null;
            };
            expect(Http.Server.prototype.hasOwnProperty('addListener')).to.be.false();
            HttpHook({ module: Http, identity: {} }, iFace);
            expect(Http.Server.prototype.hasOwnProperty('addListener')).to.be.true();

            const s = Http
                .createServer((req, res) => {

                    res.end('ok\n');
                })
                .listen();

            Http.get({ port: s.address().port }, ( res) => {

                const chunks = [];
                res.on('data', (c) => chunks.push(c));
                res.on('end', () => {

                    const payload = Buffer.concat(chunks);
                    expect(payload.toString()).to.equal('ok\n');
                    s.close(() => {

                        done();
                    });
                });
            });
        });

        it('should intercept the lifecycle of an HTTP request and prevent it to go through', { plan: 13 }, (done) => {

            const iFace = TestUtils.getEcosystemMock();

            const mockedSession = {
                run: (cb) => cb(),
                set: function (key, value) {

                    if (key === 'req') {
                        expect(value instanceof Http.IncomingMessage).to.be.true();
                    }
                    if (key === 'res') {
                        expect(value instanceof Http.ServerResponse).to.be.true();
                    }
                },
                bindEmitter: function () {}
            };
            const mockedBudget = { // TODO: must call
                startCount: function () {},
                stopCount: function () {}
            };


            iFace[INTERFACES.INSTRUMENTATION].strategies.patchFunction = function (hold, method) {};
            iFace[INTERFACES.INSTRUMENTATION].strategies.patchEventListeners = function (holder, event, hookFactory) {

                expect(event).to.equal('request');
                const addListener = holder.addListener;
                holder.addListener = function (evt, listener) {

                    if (evt === event) {
                        arguments[1] = hookFactory(this, listener);
                    }
                    return addListener.apply(this, arguments);
                };
                holder.on = holder.addListener;
                // TODO
            };
            iFace[INTERFACES.TRANSPORT].startIncomingTransaction = function (_, cb) {

                return cb(mockedSession, mockedBudget, mockedBudget);
            };
            iFace[INTERFACES.TRANSPORT].stopIncomingTransaction = function (_, cb) {

                return cb();
            };
            iFace[INTERFACES.TRANSPORT].utils.getXFFOrRemoteAddress = function (req) {

                expect(req instanceof Http.IncomingMessage).to.be.true();
                return '';
            };
            iFace[INTERFACES.TRANSPORT].utils.ensureProperIP = function (ip) {

                expect(ip).to.equal('');
                return '';
            };
            iFace[INTERFACES.ENGINE].getNeededFieldSet = function () {

                return new Set();
            };
            iFace[INTERFACES.INSTRUMENTATION].registerHttpServerForReveal = function () {};

            iFace[INTERFACES.TRANSPORT].ipAndPath.checkIPandPath = function (ipAddress, req, res) {

                expect(ipAddress).to.equal('');
                res.end('blocked\n');
                return iFace[INTERFACES.TRANSPORT].ipAndPath.ACTIONS.PREVENT;
            };
            iFace[INTERFACES.TRANSPORT].enableHTTP = function () {};
            iFace[INTERFACES.TRANSPORT].stopHttpTransaction = function () {};
            iFace[INTERFACES.TRANSPORT].getHttpTrace = function (reference, ipAddress) {

                expect(reference instanceof Http.IncomingMessage).to.be.true();
                expect(ipAddress).to.equal('');

                return {};
            };
            iFace[INTERFACES.TRACING].shouldTrace = function () {

                return null;
            };
            expect(Http.Server.prototype.hasOwnProperty('addListener')).to.be.false();
            HttpHook({ module: Http, identity: {} }, iFace);
            expect(Http.Server.prototype.hasOwnProperty('addListener')).to.be.true();

            const s = Http
                .createServer((req, res) => {

                    res.end('ok\n');
                })
                .listen();

            Http.get({ port: s.address().port }, ( res) => {

                const chunks = [];
                res.on('data', (c) => chunks.push(c));
                res.on('end', () => {

                    const payload = Buffer.concat(chunks);
                    expect(payload.toString()).to.equal('blocked\n');
                    s.close(() => {

                        done();
                    });
                });
            });
        });

        it('should intercept the lifecycle of an HTTP request and prevent it to go through', { plan: 17 }, (done) => {

            const iFace = TestUtils.getEcosystemMock();

            const mockedSession = {
                run: (cb) => cb(),
                set: function (key, value) {

                    if (key === 'req') {
                        expect(value instanceof Http.IncomingMessage).to.be.true();
                    }
                    if (key === 'res') {
                        expect(value instanceof Http.ServerResponse).to.be.true();
                    }
                },
                bindEmitter: function () {}
            };
            const mockedBudget = { // TODO: must call
                startCount: function () {},
                stopCount: function () {}
            };

            iFace[INTERFACES.INSTRUMENTATION].strategies.patchFunction = function (hold, method) {};
            iFace[INTERFACES.INSTRUMENTATION].strategies.patchEventListeners = function (holder, event, hookFactory) {

                expect(event).to.equal('request');
                const addListener = holder.addListener;
                holder.addListener = function (evt, listener) {

                    if (evt === event) {
                        arguments[1] = hookFactory(this, listener);
                    }
                    return addListener.apply(this, arguments);
                };
                holder.on = holder.addListener;
                // TODO
            };
            iFace[INTERFACES.TRANSPORT].startIncomingTransaction = function (req, cb) {

                expect(req instanceof Http.IncomingMessage).to.be.true();

                try {
                    return cb(mockedSession, mockedBudget, mockedBudget);
                }
                catch (err) {
                    req.__sqreen_res.end(err.toString());
                }
            };
            iFace[INTERFACES.TRANSPORT].stopIncomingTransaction = function (_, cb) {

                return cb();
            };
            iFace[INTERFACES.TRANSPORT].utils.getXFFOrRemoteAddress = function (req) {

                expect(req instanceof Http.IncomingMessage).to.be.true();
                return '127.0.0.1';
            };
            iFace[INTERFACES.TRANSPORT].utils.ensureProperIP = function (ip) {

                expect(ip).to.equal('127.0.0.1');
                return '127.0.0.1';
            };
            iFace[INTERFACES.ENGINE].getNeededFieldSet = function () {

                return new Set();
            };
            iFace[INTERFACES.INSTRUMENTATION].registerHttpServerForReveal = function () {};

            iFace[INTERFACES.TRANSPORT].ipAndPath.checkIPandPath = function (ipAddress, req, res) {

                expect(ipAddress).to.equal('127.0.0.1');
                return iFace[INTERFACES.TRANSPORT].ipAndPath.ACTIONS.NONE;
            };
            const trigger = {};
            iFace[INTERFACES.TRANSPORT].shouldPropagate = function (scope) {

                expect(scope).to.equal('server');
                return {
                    fields: ['transport', 'tracing_identifier'],
                    trigger
                };
            };
            iFace[INTERFACES.TRANSPORT].propagate = function (resolved, _trigger) {

                expect(resolved['server.request.transport']).to.equal('http');
                expect(resolved['server.request.tracing_identifier']).to.equal('');

                if (_trigger === trigger) {
                    throw new Error('Synchronous blocking');
                }

                return function () {};
            };
            iFace[INTERFACES.TRANSPORT].stopHttpTransaction = function () {};
            iFace[INTERFACES.TRANSPORT].getHttpTrace = function (reference, ipAddress) {

                expect(reference instanceof Http.IncomingMessage).to.be.true();
                expect(ipAddress).to.equal('127.0.0.1');

                return {};
            };
            iFace[INTERFACES.TRACING].shouldTrace = function () {

                return null;
            };

            iFace[INTERFACES.TRANSPORT].enableHTTP = function () {};
            expect(Http.Server.prototype.hasOwnProperty('addListener')).to.be.false();
            HttpHook({ module: Http, identity: { name: 'http' } }, iFace);
            expect(Http.Server.prototype.hasOwnProperty('addListener')).to.be.true();

            const s = Http
                .createServer((req, res) => {

                    res.end('ok\n');
                })
                .listen();

            Http.get({ port: s.address().port }, ( res) => {

                const chunks = [];
                res.on('data', (c) => chunks.push(c));
                res.on('end', () => {

                    const payload = Buffer.concat(chunks);
                    expect(payload.toString()).to.equal('Error: Synchronous blocking');
                    s.close(() => {

                        done();
                    });
                });
            });
        });

        it('should not track this since req is not en event emitter', { plan: 1 }, (done) => {

            const iFace = TestUtils.getEcosystemMock();
            iFace[INTERFACES.TRANSPORT].enableHTTP = function () {};
            iFace[INTERFACES.INSTRUMENTATION].strategies.patchFunction = function () {};
            iFace[INTERFACES.INSTRUMENTATION].registerHttpServerForReveal = function () {};
            iFace[INTERFACES.INSTRUMENTATION].strategies.patchEventListeners = function (_, __, factory) {

                const listener = factory(this, (req) => {

                    expect(req.__sqreen_uuid).to.not.exist();
                    done();
                });
                listener({});
            };
            HttpHook({ module: Http, identity: {} }, iFace);
        });
    });
});
